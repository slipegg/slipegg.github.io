<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IDEA远程开发选项丢失修复方法</title>
    <link href="/2023/12/01/IDEA%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%80%89%E9%A1%B9%E4%B8%A2%E5%A4%B1%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/01/IDEA%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%80%89%E9%A1%B9%E4%B8%A2%E5%A4%B1%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>今天打开IDEA发现远程开发选项没有了：</p><p><img src="/2023/12/01/IDEA%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%80%89%E9%A1%B9%E4%B8%A2%E5%A4%B1%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/%E6%8D%9F%E5%9D%8F%E7%95%8C%E9%9D%A2.jpg" alt="损坏界面"></p><p>发现全网也没有什么提到过这个错误的，所有捣鼓了好久还进行了IDEA的重装也一直都没有解决，最后查看<a href="https://www.jetbrains.com/help/idea/2023.2/jetbrains-gateway.html#plugin_install">IDEA官方的介绍文档</a>才发现了问题所在：<strong>Remote Development Gateway插件被关闭了</strong></p><p>故而解决方法就是点击IDEA的设置选项卡，在插件(plugs)选项中重新勾选<code>Remote Development Gateway</code>来启用该插件即可</p><p><img src="/2023/12/01/IDEA%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%80%89%E9%A1%B9%E4%B8%A2%E5%A4%B1%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.jpg" alt="解决方法"></p><p>点击启用后可以发现远程开发选项又回来了：</p><p><img src="/2023/12/01/IDEA%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%80%89%E9%A1%B9%E4%B8%A2%E5%A4%B1%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/%E4%BF%AE%E5%A4%8D%E5%90%8E%E7%95%8C%E9%9D%A2.jpg" alt="修复后界面"></p><p>所以还是要多从官方的信息源找起啊</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.824】lab 1 MapReduce实现总结</title>
    <link href="/2023/11/22/MIT6-824lab1/"/>
    <url>/2023/11/22/MIT6-824lab1/</url>
    
    <content type="html"><![CDATA[<p>MIT6.824是一门经典的分布式课程，课程链接：<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">https://pdos.csail.mit.edu/6.824/labs/lab-mr.html</a>，对于lab 1我们需要在提供的代码框架的基础上补充coordinator和worker的代码，以实现分布式的MapReduce程序。</p><p>本人在借鉴了部分其他人的设计思想的基础上，独立完成了所有的代码，最后设计的实现能够通过所有的测试脚本。</p><p>实现的代码厂库：<a href="https://github.com/slipegg/MIT6.824/tree/main/6.5840">https://github.com/slipegg/MIT6.824/tree/main/6.5840</a></p><h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>在给定的代码框架中实现一个单词计数的MapReduce程序。原本的框架中已经给了一个在本地串行执行单词计数的独立程序，并提供了一个通过UNIX-domain sockets实现的RPC(<a href="https://slipegg.github.io/2023/11/14/RPC%E4%BB%8B%E7%BB%8D/">RPC介绍</a>)，我们需要完成的部分有：</p><ol><li>设计coordinator和worker之间交流的流程和格式，以方便worker向coordinator申请任务，coordinator将taks发送给worker，worker把task的完成情况返回给coordinator</li><li>coordinator对Map类型的task和Reduce类型的task进行管理，需要初始化这些任务，需要记录任务完成的情况，并生成新的任务，直到全部完成</li><li>worker如何完成Map类型以及Reduce类型task</li></ol><h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p><strong>worker</strong>会不断向coordinator发送心跳，申请任务，拿到任务后进行map或者renduce类型的task的执行，在执行完毕后发送请求给coordinator以表示该任务完成了。当coordinator告诉其所有任务都完成时，他会结束运行</p><p><strong>coordinator</strong>只维护task的状态不维护各个worker的状态。worker向其发送心跳申请任务时，coordinator会去遍历任务，取出还没有发送的任务或者过了太长时间都没有完成的任务返回回去，如果没有，就返回一个等待任务。coordinator接收到worker的某个任务完成的请求时会改变这个任务的状态，如果当前阶段所有的任务都完成了就转向下一个阶段，知道转到了所有MapReduce任务都完成的阶段。</p><p>整体流程如下图所示：</p><p><img src="/./MIT6-824lab1/MapReduce.png" alt="MapReduce流程"></p><h1 id="rpc信息传递设计"><a href="#rpc信息传递设计" class="headerlink" title="rpc信息传递设计"></a>rpc信息传递设计</h1><h2 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h2><p>worker通过rpc向coordinator发送心跳（Heartbeat）来申请任务。如下：</p><ul><li><p>关键结构体定义如下，HeartbeatRequest是个空结构，HeartbeatResponse承载了coordinator返回给worker的信息，这里的信息实际上是运行map类型和reduce类型的task所必须的信息的集合。所有的返回都需要JobType来标明其类型，需要id来标明其是哪个作业，<strong>对于map类型作业</strong>，其额外需要FilePath来获取任务的输入，还需要NReduce来决定输出的数量，<strong>对于reduce类型作业</strong>，其额外需要NMap来辅助获取map类型的中间输出。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HeartbeatRequest <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> HeartbeatResponse <span class="hljs-keyword">struct</span> &#123;<br>    FilePath <span class="hljs-type">string</span><br>    JobType  JobType<br>    NReduce  <span class="hljs-type">int</span><br>    NMap     <span class="hljs-type">int</span><br>    Id       <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用请求如下，它会调用coordinator的heartbeat函数来处理，并将任务返回到response中。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">call(<span class="hljs-string">&quot;Coordinator.Heartbeat&quot;</span>, &amp;HeartbeatRequest&#123;&#125;, &amp;response)<br></code></pre></td></tr></table></figure></li></ul><h2 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h2><p>worker完成任务后通过rpc向coordinator发送回复。如下：</p><ul><li><p>关键结构体设计如下。ReportRequest通过phase和id来联合表示是哪个任务完成了。</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">ReportRequest</span> struct &#123;<br>    <span class="hljs-type">Id</span>    int<br>    <span class="hljs-type">Phase</span> <span class="hljs-type">SchedulePhase</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">ReportResponse</span> struct &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>调用请求如下,它会调用coordinator的Report函数来处理，来将该任务标记为运行结束。</p>  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">call(<span class="hljs-string">&quot;Coordinator.Report&quot;</span>, <span class="hljs-symbol">&amp;ReportRequest</span>&#123;Id: id, Phase: phase&#125;, <span class="hljs-symbol">&amp;ReportResponse</span>&#123;&#125;)<br></code></pre></td></tr></table></figure></li></ul><h1 id="coordinator设计"><a href="#coordinator设计" class="headerlink" title="coordinator设计"></a>coordinator设计</h1><p>coordinator会衍生出2个额外的协程，一个负责给rpc注册，并响应rpc传来的函数调用请求，一个负责给worker选择task生成resopnse</p><h2 id="rpc函数调用处理"><a href="#rpc函数调用处理" class="headerlink" title="rpc函数调用处理"></a>rpc函数调用处理</h2><p>给rpc注册的程序就是原本框架提供的代码，具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// start a thread that listens for RPCs from worker.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> server() &#123;<br>rpc.Register(c)<br>rpc.HandleHTTP()<br><span class="hljs-comment">//l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)</span><br>sockname := coordinatorSock()<br>os.Remove(sockname)<br>l, e := net.Listen(<span class="hljs-string">&quot;unix&quot;</span>, sockname)<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;listen error:&quot;</span>, e)<br>&#125;<br><span class="hljs-keyword">go</span> http.Serve(l, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其相应的也是上面提到的hearbeat和report事件。比较有go特色的的地方在于如何等待另一个进程生成对应的回应，采用的是如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> heartbeatMsg <span class="hljs-keyword">struct</span> &#123;<br>response *HeartbeatResponse<br>ok       <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Heartbeat(request *HeartbeatRequest, response *HeartbeatResponse) <span class="hljs-type">error</span> &#123;<br>msg := heartbeatMsg&#123;response, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>c.heartbeatCh &lt;- msg<br>&lt;-msg.ok<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构建msg将信息传递过去给c.heartbeach，然后等待msg.ok准备就绪，也就是response填好了数据，再返回。Report也是同理</p><h2 id="task管理"><a href="#task管理" class="headerlink" title="task管理"></a>task管理</h2><p>在coordinator初始化时会生成一个schedule协程来负责task生成和管理</p><ul><li>task有4种类型Map类型、Reduce类型、等待类型和完成类型，Map类型和Reduce类需要worker进行实际处理，等待类型只需要worker去sleep一段时间就好了，然后再去询问有没有新任务，完成类型的任务发送过来之后worker就可以结束运行了</li><li>task有3个状态，分别为等待、运行、完成，一开始初始化时为等待状态，交给worker运行后为运行状态，worker发送report回来说明自己运行完毕后为完成状态。</li><li>coordinator有三个阶段分别为Map阶段、Reduce阶段和Complete阶段，一开始为Map阶段，其需要处理Map类型的task，当Map类型的task全部完成后需要转变到Reduce阶段，处理Reduce类型的task，当Reduce类型的状态也全部完成后就转为Complete状态，可以结束运行了。</li></ul><p>schedule代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> schedule() &#123;<br>c.initMapPhase()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> msg := &lt;-c.heartbeatCh:<br>isAllTaskDoneInPhase := c.selectANewTask(msg.response)<br><span class="hljs-keyword">if</span> isAllTaskDoneInPhase &#123;<br>c.switchPhase()<br>c.selectTaskAfterSwitchPhase(msg.response)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;Coordinator: Heartbeat response: %v\n&quot;</span>, msg.response)<br>msg.ok &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-keyword">case</span> msg := &lt;-c.reportCh:<br><span class="hljs-keyword">if</span> msg.request.Phase == c.phase &#123;<br>log.Printf(<span class="hljs-string">&quot;Coordinator: Worker has finished %v-task%d\n&quot;</span>, c.phase, msg.request.Id)<br>c.tasks[msg.request.Id].status = Finished<br>&#125;<br>msg.ok &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成一个新任务时需要去遍历查看是否有处于等待状态的任务或者是运行时间过久（说明worker可能已经挂掉了）的任务，然后将其分配出去，主要代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> selectANewTask(response *HeartbeatResponse) <span class="hljs-type">bool</span> &#123;<br>isAllTaskDone, isNewTaskScheduled := <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">for</span> id, task := <span class="hljs-keyword">range</span> c.tasks &#123;<br><span class="hljs-keyword">switch</span> task.status &#123;<br><span class="hljs-keyword">case</span> Idle:<br>isAllTaskDone, isNewTaskScheduled = <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span><br>c.tasks[id].status, c.tasks[id].startTime = Working, time.Now()<br>c.scheduleTaskToResponse(id, response)<br><br><span class="hljs-keyword">case</span> Working:<br>isAllTaskDone = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> time.Since(task.startTime) &gt; MaxTaskRunInterval &#123;<br>isNewTaskScheduled = <span class="hljs-literal">true</span><br>c.tasks[id].startTime = time.Now()<br>c.scheduleTaskToResponse(id, response)<br>&#125;<br><br><span class="hljs-keyword">case</span> Finished:<br>&#125;<br><br><span class="hljs-keyword">if</span> isNewTaskScheduled &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !isNewTaskScheduled &amp;&amp; !isAllTaskDone &#123;<br>response.JobType = WaitJob<br>&#125;<br><br><span class="hljs-keyword">return</span> isAllTaskDone<br>&#125;<br></code></pre></td></tr></table></figure><p>当coordinator进行Complete阶段后其实并不会再去处理其他事情，比如给worker发送运行结束的指令，而是直接给doneCh赋值，然后以此退出运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Done() <span class="hljs-type">bool</span> &#123;<br>&lt;-c.doneCh<br>log.Printf(<span class="hljs-string">&quot;Coordinator: Done\n&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="worker-设计"><a href="#worker-设计" class="headerlink" title="worker 设计"></a>worker 设计</h1><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>worker就是不断地发送heartbeat命令然后获取任务进行运行，直到接收到了Complete任务或者发送heartbeat失败，就可以结束运行了。如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue,<br>reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<br><br><span class="hljs-keyword">for</span> &#123;<br>response := doHeartbeat()<br>log.Printf(<span class="hljs-string">&quot;Worker: receive coordinator&#x27;s response, new job is %v \n&quot;</span>, response)<br><br><span class="hljs-keyword">switch</span> response.JobType &#123;<br><span class="hljs-keyword">case</span> MapJob:<br>doMapTask(mapf, response)<br><span class="hljs-keyword">case</span> ReduceJob:<br>doReduceTask(reducef, response)<br><span class="hljs-keyword">case</span> WaitJob:<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">case</span> CompleteJob:<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;worker get an unexpected jobType %v&quot;</span>, response.JobType))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map类型task"><a href="#Map类型task" class="headerlink" title="Map类型task"></a>Map类型task</h2><p>Map类型的task的处理如下所示，总体就是调用mapF统计文件中各个单词的数量，并记录到中间文件中，由于将中间结果写入到文件中是可以并行运行的，所以这里启动了多个协程来进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doMapTask</span><span class="hljs-params">(mapF <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue, response *HeartbeatResponse) &#123;<br>wordCountList := getWordCountListOfFile(mapF, response.FilePath)<br><br>intermediate := splitWordCountListToReduceNNum(wordCountList, response.NReduce)<br><br><span class="hljs-keyword">var</span> writeIntermediateFilewg sync.WaitGroup<br><span class="hljs-keyword">for</span> reduceNumber, splitedWordCountList := <span class="hljs-keyword">range</span> intermediate &#123;<br>writeIntermediateFilewg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(reduceNumber <span class="hljs-type">int</span>, splitedWordCountList []KeyValue)</span></span> &#123;<br><span class="hljs-keyword">defer</span> writeIntermediateFilewg.Done()<br>writeIntermediateFile(response.Id, reduceNumber, splitedWordCountList)<br>&#125;(reduceNumber, splitedWordCountList)<br>&#125;<br>writeIntermediateFilewg.Wait()<br><br>doReport(response.Id, MapPhase)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reduce类型task"><a href="#Reduce类型task" class="headerlink" title="Reduce类型task"></a>Reduce类型task</h2><p>Reduce类型task的处理如下所示，总体就是把对应的中间文件读出来，将结果通过reduceF进行聚集，输出到最终的文件中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doReduceTask</span><span class="hljs-params">(reduceF <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>, response *HeartbeatResponse) &#123;<br>wordCountList := getWordCountListFromIntermediateFile(response.NMap, response.Id)<br><br>wordCountMap := gatherAndSortIntermediateWordCountList(wordCountList)<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>reducIntermediateWordCount(reduceF, wordCountMap, &amp;buf)<br><br>fileName := generateReduceResultFileName(response.Id)<br>atomicWriteFile(fileName, &amp;buf)<br><br>doReport(response.Id, ReducePhase)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子写入文件"><a href="#原子写入文件" class="headerlink" title="原子写入文件"></a>原子写入文件</h2><p>这里采用了一种原子写入的方式，以防止多个worker都需要写入同一个文件名的文件时可能出现的问题。总体思想就是先写入到一个临时文件中，然后再将其改名为对应的文件名，如果临时文件没有写成功，就用defer命令将其删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">atomicWriteFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>, reader io.Reader)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>tmpFileName, err := writeToTmpFile(filename, reader)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;cannot write to temp file: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := os.Rename(tmpFileName, filename); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;cannot rename temp file: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeToTmpFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>, reader io.Reader)</span></span> (tmpFileName <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br>dir, file := filepath.Split(filename)<br><span class="hljs-keyword">if</span> dir == <span class="hljs-string">&quot;&quot;</span> &#123;<br>dir = <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br><br>tmpFile, err := os.CreateTemp(dir, file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;cannot create temp file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> tmpFile.Close()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>os.Remove(tmpFile.Name())<br>&#125;<br>&#125;()<br><br>_, err = io.Copy(tmpFile, reader)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;cannot write to temp file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := tmpFile.Close(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;cannot close temp file: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">return</span> tmpFile.Name(), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>coordinator运行结果:</p><p><img src="/./MIT6-824lab1/coordinator%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="coordinator运行结果"></p><p>worker运行结果:</p><p><img src="/./MIT6-824lab1/worker%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="worker运行结果"></p><p>中间文件：</p><p><img src="/./MIT6-824lab1/%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6.jpg" alt="中间文件"></p><p>输出结果：</p><p><img src="/./MIT6-824lab1/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.jpg" alt="输出结果"></p><p>测试脚本结果：</p><p><img src="/./MIT6-824lab1/%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%9C.jpg" alt="测试脚本结果"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最后进行脚本测试的时候发现early_exit这个点总是通不过，这个脚本会捕捉最早退出运行的进程，然后拷贝所有输出文件，然后再在所有进程都退出的时候拷贝所有输出文件，以此对比两个文件是否相同，来判断是否coordinator和所有的woker都在任务全部完成后再退出。</p><p>后面仔细查看不通过的原因发现是因为其依靠下面的部分来进行捕捉退出的进程,本机器上使用的是<code>wait -n</code>,但是实际查看发现其并没有正确地在相关进程退出时进行触发，而是一开始就触发了，其触发时coordinator和所有worker其实都还在前台运行了，后面讲这部分改成了if里面的测试，就可以正常捕捉退出的进程然后顺利通过了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">jobs</span> &amp;&gt; /dev/null<br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$OSTYPE</span>&quot;</span> = <span class="hljs-string">&quot;darwin&quot;</span>* ]]<br><span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># bash on the Mac doesn&#x27;t have wait -n</span><br>  <span class="hljs-keyword">while</span> [ ! -e <span class="hljs-variable">$DF</span> ]<br>  <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">sleep</span> 0.2<br>  <span class="hljs-keyword">done</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-comment"># the -n causes wait to wait for just one child process,</span><br>  <span class="hljs-comment"># rather than waiting for all to finish.</span><br>  <span class="hljs-built_in">wait</span> -n<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>从看MapReduce论文到学go再到能看懂作业要求，再到能看懂别人写的代码，再到能自己独立完成这部分代码总共断断续续持续了一个月，能够感受到自己在这之中的不断的精进，MapReduce的设计确实也很巧妙，go总体的设计确实很适合分布式，MIT6.824确实不愧是一名深受好评的课，学一下是很有必要的，希望自己后面也能都将其他部分啃下来了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021">https://github.com/OneSizeFitsQuorum/MIT6.824-2021</a></li><li><a href="https://github.com/PKUFlyingPig/MIT6.824">https://github.com/PKUFlyingPig/MIT6.824</a></li><li><a href="https://github.com/szw2021/MIT6.824-2021/tree/practice/src">https://github.com/szw2021/MIT6.824-2021/tree/practice/src</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>go</category>
      
      <category>MIT6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC介绍</title>
    <link href="/2023/11/14/RPC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/11/14/RPC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">最近在学MIT6.824的lab1——MapReduce，发现其中使用到了RPC来让work和coordinator之间通信，故而乘机学习一下。</code></pre><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>RPC（Remote Procedure Call，远程过程调用）是一种在分布式系统中进行进程间通信的协议。它允许一个程序（客户端）调用另一个程序（服务器）上的函数或过程，就像调用本地函数一样，而不必关心底层网络细节。</p><p>在 RPC 中，客户端和服务器可以在不同的机器上，甚至在不同的网络上。RPC 提供了一种抽象，使得远程调用看起来就像是本地调用一样。通过 RPC，程序可以通过网络传输数据和调用远程函数，使得分布式系统中的组件可以协同工作。</p><p>其整体流程如下图所示：</p><p><img src="https://pic4.zhimg.com/45366c44f775abfd0ac3b43bccc1abc3_b" alt="RPC流程"></p><p>对于RPC需要关注的主要有三点：</p><ul><li><strong>通信协议：</strong> RPC可以基于TCP或者HTTP协议，一般而言TCP的协议更快</li><li><strong>寻址：</strong> 远程提供服务器需要提供服务所在地址，例如IP和端口</li><li><strong>数据序列化：</strong> 远程调用无法依据内存进行参数和结果传递，所以需要规定序列化的格式，例如Json格式</li></ul><p>常用的RPC框架有如下这些： </p><ul><li>Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li><li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</li><li>Dubbo：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</li><li>Spring Cloud：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</li></ul><h1 id="GO语言示例"><a href="#GO语言示例" class="headerlink" title="GO语言示例"></a>GO语言示例</h1><p>在 Go 语言中，标准库提供了一个 net&#x2F;rpc 包，用于实现 RPC。基本的使用流程包括注册对象、注册服务、处理请求等。以下是一个简单的 Go RPC 例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个用于 RPC 的对象</span><br><span class="hljs-keyword">type</span> MyService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 定义一个 RPC 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyService)</span></span> Multiply(args *Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>*reply = args.A * args.B<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 定义传递给 RPC 方法的参数结构</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span> &#123;<br>A, B <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注册服务</span><br>rpc.Register(<span class="hljs-built_in">new</span>(MyService))<br><br><span class="hljs-comment">// 创建监听器</span><br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 处理连接</span><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> rpc.ServeConn(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该例子中，MyService 结构体中的 Multiply 方法被注册为 RPC 服务。通过监听端口 1234，该服务可以接收客户端的 RPC 调用请求。客户端可以通过 net&#x2F;rpc 包中的函数来发起远程调用。RPC 在分布式系统中广泛用于实现不同节点之间的通信和协作。</p><p>以下是一个简单的 Go RPC 客户端的调用代码示例,程序需要确保 RPC 客户端的网络协议和端口与服务器端一致，这样它们才能正确地进行通信。在这个例子中，服务器端监听的是 TCP 端口 1234。：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-comment">// 定义传递给 RPC 方法的参数结构</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span> &#123;<br>A, B <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RPC 服务器</span><br>client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> client.Close()<br><br><span class="hljs-comment">// 准备 RPC 调用的参数</span><br>args := Args&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br><span class="hljs-comment">// 调用 Multiply 方法</span><br><span class="hljs-keyword">var</span> result <span class="hljs-type">int</span><br>err = client.Call(<span class="hljs-string">&quot;MyService.Multiply&quot;</span>, args, &amp;result)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 打印结果</span><br>fmt.Printf(<span class="hljs-string">&quot;Result of 3 * 4: %d\n&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，rpc.Dial 函数用于连接到服务器，然后通过 client.Call 方法调用远程的 Multiply 方法。在调用过程中，需要传递参数结构 Args 和一个用于接收结果的变量。最后，打印出调用结果:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Result</span> of <span class="hljs-number">3</span> * <span class="hljs-number">4</span>: <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://jaminzhang.github.io/architecture/RPC-Introduction/">https://jaminzhang.github.io/architecture/RPC-Introduction/</a></li><li><a href="https://zhuanlan.zhihu.com/p/187560185">https://zhuanlan.zhihu.com/p/187560185</a></li><li><a href="https://cloud.tencent.com/developer/article/2021745">https://cloud.tencent.com/developer/article/2021745</a></li><li><a href="https://chat.openai.com/">ChatGPT</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何写出优雅的代码</title>
    <link href="/2023/11/09/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/11/09/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近在写模拟器的代码，现在需要对整体的架构都进行一个大更改，而当我回过头去看时发现好多代码都写得很丑，越写越像屎山代码，需要对整体进行一轮迭代，故而正好趁此机会来学习一下如何写一个优雅的代码。写之前看了很多博客，这里记录一下对自己比较有启发的点。</p><h1 id="什么是优雅的代码"><a href="#什么是优雅的代码" class="headerlink" title="什么是优雅的代码"></a>什么是优雅的代码</h1><pre><code class="hljs">这一个衡量标准很直接：WTF min</code></pre><p><img src="https://camo.githubusercontent.com/ded622d3db4ad28f7b47098ae182c09dc1d629c90f487a885f683527825ecc94/687474703a2f2f692e737461636b2e696d6775722e636f6d2f65545a76572e6a7067" alt="优雅的代码"></p><p>代码最后还是需要给人读的，需要认识到：</p><pre><code class="hljs">任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。—— Martin Fowler</code></pre><p>好的代码最重要的特点：整洁</p><pre><code class="hljs">整洁的代码如同优美的散文。—— Grady Booch</code></pre><h1 id="如何保证代码整洁"><a href="#如何保证代码整洁" class="headerlink" title="如何保证代码整洁"></a>如何保证代码整洁</h1><h2 id="1-有意义的命名"><a href="#1-有意义的命名" class="headerlink" title="1. 有意义的命名"></a>1. 有意义的命名</h2><p>命名要尽可能地输出多的信息，让人能快速理解这个类、变量或者函数的含义、功能。<strong>花时间来取名是值得的</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 创建后的天数</span><br><span class="hljs-comment">**/</span><br><span class="hljs-built_in">int</span> d;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int daysSinceCreation<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>后一种命名就能够更加凸显变量的含义了。</p><p>命名是越短越好的，但是为了能够清晰表达意思，取长名字也是值得的。</p><p>尽量不要取相似的名字以让人困惑。</p><h2 id="2-优雅的注释"><a href="#2-优雅的注释" class="headerlink" title="2. 优雅的注释"></a>2. 优雅的注释</h2><p>一份优雅的代码本身就应该具有足够的表达力，不需要注释就能看懂。<strong>注释的存在往往是弥补我们无法用代码清晰表达意图的情况</strong>。当发现自己需要对某处的代码写注释时就需要考虑是不是应该用更好的代码对其进行替代了。</p><pre><code class="hljs">好代码&gt;&gt;坏代码+注释</code></pre><p>注释应该只需要注重解释上层的东西，包括设计的意图、功能，而不需要解释执行的细节，这由代码来进行展示。</p><p>注释不要去写能由git记录的信息。</p><h2 id="3-简洁的函数"><a href="#3-简洁的函数" class="headerlink" title="3. 简洁的函数"></a>3. 简洁的函数</h2><p>控制函数的长度，一般不要长于一个屏幕的大小，也就是<strong>控制在30行以内</strong></p><p><strong>if语句、else语句、while语句等，其中的代码应该只有一行</strong>，该行通常是一个调用语句，这样不但能保持短小，还可以给调用方法命名一个有说明性的名字，进一步增加代码的可读性</p><p>函数的功能要单一，具有原子性，以方便函数复用。最简单的规则就是看看该方法是否能在拆出一个方法，且拆出去的方法是不同于该方法的诠释和实现。</p><p>需要保证函数中的抽象层级一致。</p><p>不要返回null或者特殊对象等，不要传入null。</p><p>函数参数不要超过3个，如果超过就需要考虑将其抽象为类。</p><h2 id="4-整齐的代码结构"><a href="#4-整齐的代码结构" class="headerlink" title="4. 整齐的代码结构"></a>4. 整齐的代码结构</h2><p>一个文件的代码数量需要<strong>控制在200行以内</strong>，最多不要超过500行。</p><p>关系紧密的代码放在一起</p><ul><li>变量声明放在其使用的位置</li><li>函数的调用者要放在被调用者上面，以从上到下展示调用依赖顺序</li></ul><p>对象暴露行为，隐藏数据，调用对象时不应该了解该对象的内部情况。</p><p>一组代码代表一个完整的思路，不同组的代码中间要用空行间隔。</p><h2 id="5-重构代码"><a href="#5-重构代码" class="headerlink" title="5. 重构代码"></a>5. 重构代码</h2><p>好代码不是一蹴而就的，重构代码是必要的。</p><p>重复的代码肯定是可以抽象出一个上层函数的。</p><ul><li>都同一个类中就考虑将其提炼出一个函数</li><li>不在同一个类中，就需要考虑创建一个共享的地方，可以是一个工具类，以便多个类都可以使用它</li><li>只是相似的话，可以重拍顺序，将相同的部分提料出来</li></ul><p>过长的函数可以通过提取函数的方式来缩短。</p><p>如果一个类不是单一职责的，则可能会导致一旦其变化就需要修改多个其他类，或者不同类的变化都需要修改这个类，这时就需要考虑对其重构，划定职责。</p><p>有时候会发现三四个相同的字段，在多个类和函数中均出现，这时候说明有必要给这一组字段建立一个类，将其封装起来。</p><p>以查询代替临时变量，也就是对于复杂的赋值表达式，使用函数来进行替代。</p><p>对于复杂过长的函数，可能将其转化为一个类进行重构。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>写一份优雅的代码远比写一份能跑的代码难，但是这是值得的。想如何写代码远比写代码来得更加重要，写代码时的角度需要变化，不要以自己的角度去看自己写的代码，而是要以一个代码阅读者的角度来审视自己的代码。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403801&idx=1&sn=5dab2af09f753fd089fe0f1f56260b10&chksm=83953bc1b4e2b2d79f78028ed6e79651167d85bf67453af791d9304fa4003eed73d9f2957fc7&scene=21#wechat_redirect">阿里工程师谈，什么是好的代码？</a></li><li><a href="https://developer.aliyun.com/article/1117703">一文详解｜如何写出优雅的代码</a></li><li><a href="https://www.zhihu.com/question/28492982">如何写出优雅的代码？</a></li><li><a href="https://juejin.cn/post/7016992016521232421">如何写出优雅的代码？</a></li><li><a href="https://github.com/CodingDocs/advanced-programmer/blob/master/docs/%E5%85%AB%E7%82%B9%E5%BB%BA%E8%AE%AE%E5%8A%A9%E6%82%A8%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84Java%E4%BB%A3%E7%A0%81.md">八点建议助您写出优雅的Java代码</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>代码风格</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文阅读】MapReduce: Simplified Data Processing on Large Clusters</title>
    <link href="/2023/11/05/MapReducePaperRead/"/>
    <url>/2023/11/05/MapReducePaperRead/</url>
    
    <content type="html"><![CDATA[<p>原博客链接：<a href="https://tanxinyu.work/mapreduce-thesis/">https://tanxinyu.work/mapreduce-thesis/</a></p><h1 id="相关背景"><a href="#相关背景" class="headerlink" title="相关背景"></a>相关背景</h1><p>在 20 世纪初，包括本文作者在内的 Google 的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web 请求日志等等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web 文档的图结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。</p><h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><p>大多数以上提到的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>为了解决上述复杂的问题，本文设计一个新的抽象模型，使用这个抽象模型，用户只要表述想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面：利用一个输入 key&#x2F;value pair 集合来产生一个输出的 key&#x2F;value pair 集合。</p><p>MapReduce 库的用户可以用两个函数表达这个计算：Map 和 Reduce。</p><ul><li>用户自定义的 Map 函数接受一个输入的 key&#x2F;value pair 值，然后产生一个中间 key&#x2F;value pair 值的集合。MapReduce 库把所有具有相同中间 key 值 I 的中间 value 值集合在一起后按照一定的规律传递给 reduce 函数。</li><li>用户自定义的 Reduce 函数接受一个中间 key 的值 I 和相关的一个 value 值的集合。Reduce 函数合并这些 value 值，形成一个较小的 value 值的集合。一般的，每次 Reduce 函数调用只产生 0 或 1 个输出 value 值。通常 Map 通过一个迭代器把中间 value 值提供给 Reduce 函数，这样 Reduce Worker 就可以处理无法全部放入内存中的大量的 value 值的集合。<br>在概念上，用户定义的 Map 和 Reduce 函数都有相关联的类型：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">map</span><span class="hljs-function"><span class="hljs-params">(k1,v1)</span> -&gt;</span><span class="hljs-keyword">list</span>(k2,v2)<br>reduce<span class="hljs-function"><span class="hljs-params">(k2,<span class="hljs-keyword">list</span>(v2))</span> -&gt;</span><span class="hljs-keyword">list</span>(v2)<br></code></pre></td></tr></table></figure><p>比如，输入的 key 和 value 值与输出的 key 和 value 值在类型上推导的域不同。此外，中间 key 和 value 值与输出 key 和 value 值在类型上推导的域相同。</p><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><p>通过将 Map 调用的输入数据自动分割为 M 个数据片段的集合，Map 调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将 Map 调用产生的中间 key 值分成 R 个不同分区（例如，hash(key) mod R），Reduce 调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p><p><img src="https://tanxinyu.work/mapreduce-thesis/mapreduce.png" alt="执行流程"></p><p>上图展示了 MapReduce 实现中操作的全部流程。当用户调用 MapReduce 函数时，将发生下面的一系列动作：</p><ol><li>用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从 16MB 到 64MB（可以通过可选的参数来控制每个数据片段的大小）。然后用户程序在机群中创建大量的程序副本。</li><li>这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配给一个空闲的 worker。</li><li>被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key&#x2F;value pair，然后把 key&#x2F;value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key&#x2F;value pair，并缓存在内存中。</li><li>缓存中的 key&#x2F;value pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的 key&#x2F;value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker</li><li>当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 Map worker 所在主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li><li>Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 程序将这个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。</li><li>当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里的对 MapReduce 调用才返回。</li></ol><h1 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h1><h2 id="worker-故障"><a href="#worker-故障" class="headerlink" title="worker 故障"></a>worker 故障</h2><p>master 与 worker 之间同步心跳，对于失效的 worker，根据其类型来做进一步处理：</p><ul><li>Map worker 故障：由于 Map 任务将数据临时存储在本地，所以需要重新执行。</li><li>Reduce worker 故障：由于 Reduce 任务将数据存储在全局文件系统中 ，所以不需要重新执行。</li></ul><h2 id="master-故障"><a href="#master-故障" class="headerlink" title="master 故障"></a>master 故障</h2><p>MapReduce 任务重新执行</p><h2 id="故障语义保证"><a href="#故障语义保证" class="headerlink" title="故障语义保证"></a>故障语义保证</h2><p>当用户提供的 Map 和 Reduce 操作是输入确定性函数（即相同的输入产生相同的输出）时，MapReduce 的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p><ul><li>Map worker 任务的原子提交：每个 Map 任务生成 R 个本地临时文件，当一个 Map 任务完成时，worker 发送一个包含 R 个临时文件名的完成消息给 master。如果 master 从一个已经完成的 Map 任务再次接收到一个完成消息，master 将忽略这个消息；</li><li>Reduce worker 任务的原子提交：当 Reduce 任务完成时，Reduce worker 进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个 Reduce 任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。MapReduce 依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 Reduce 任务产生的数据。</li></ul><h1 id="存储位置优化"><a href="#存储位置优化" class="headerlink" title="存储位置优化"></a>存储位置优化</h1><p>核心思想：本地读文件以减少流量消耗</p><p>MapReduce 的 master 在调度 Map 任务时会考虑输入文件的位置信息，尽量将一个 Map 任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，master 将尝试在保存有输入数据拷贝的机器附近的机器上执行 Map 任务（例如，分配到一个和包含输入数据的机器在一个交换机里的 worker 机器上执行）。</p><h1 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h1><p>理想情况下，M 和 R 应当比集群中 worker 的机器数量要多得多。在每台 worker 机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度：失效机器上执行的大量 Map 任务都可以分布到所有其他的 worker 机器上去执行。</p><p>实际使用时建议用户选择合适的 M 值，以使得每一个独立任务都是处理大约 16M 到 64M 的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，也建议把 R 值设置使用的 worker 机器数量的小倍数。比如：M&#x3D;200000，R&#x3D;5000，使用 2000 台 worker 机器。</p><h1 id="备用任务"><a href="#备用任务" class="headerlink" title="备用任务"></a>备用任务</h1><p>影响一个 MapReduce 的总执行时间最通常的因素是“落伍者”：在运算过程中，如果有一台机器花了很长的时间才完成最后几个 Map 或 Reduce 任务，导致 MapReduce 操作总的执行时间超过预期。</p><p>为了解决落伍者的问题，当一个 MapReduce 操作接近完成的时候，master 调度备用（backup）任务进程来执行剩下的、处于处理中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，MapReduce 都把这个任务标记成为已经完成。此个机制通常只会占用比正常操作多几个百分点的计算资源。但能减少近 50% 的任务完成总时间。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="分区函数"><a href="#分区函数" class="headerlink" title="分区函数"></a>分区函数</h2><p>MapReduce 缺省的分区函数是使用 hash 方法(比如，hash(key) mod R) 进行分区。hash 方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 key 值进行的分区将非常有用。比如，输出的 key 值是 URLs，有的用户希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce 库的用户需要提供专门的分区函数。例如，使用“hash(Hostname(urlkey))mod R”作为分区函数就可以把所有来自同一个主机的 URLs 保存在同一个输出文件中。</p><h2 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h2><p>MapReduce 确保在给定的分区中，中间 key&#x2F;value pair 数据的处理顺序是按照 key 值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按 key 值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p><h2 id="Combiner-函数"><a href="#Combiner-函数" class="headerlink" title="Combiner 函数"></a>Combiner 函数</h2><p>在某些情况下，Map 函数产生的中间 key 值的重复数据会占很大的比重，并且，用户自定义的 Reduce 函数满足结合律和交换律。在 2.1 节的词数统计程序是个很好的例子。由于词频率倾向于一个 zipf 分布（齐夫分布），每个 Map 任务将产生成千上万个这样的记录。所有的这些记录将通过网络被发送到一个单独的 Reduce 任务，然后由这个 Reduce 任务把所有这些记录累加起来产生一个数字。MapReduce 允许用户指定一个可选的 combiner 函数，combiner 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</p><p>Combiner 函数在每台执行 Map 任务的机器上都会被执行一次。一般情况下，Combiner 和 Reduce 函数是一样的。Combiner 函数和 Reduce 函数之间唯一的区别是 MapReduce 库怎样控制函数的输出。Reduce 函数的输出被保存在最终的输出文件里，而 Combiner 函数的输出被写到中间文件里，然后被发送给 Reduce 任务。</p><p>部分的合并中间结果可以显著的提高一些 MapReduce 操作的速度。</p><h2 id="输入和输出的类型"><a href="#输入和输出的类型" class="headerlink" title="输入和输出的类型"></a>输入和输出的类型</h2><p>支持常用的类型，可以通过提供一个简单的 Reader 接口实现来支持一个新的输入类型。Reader 并非一定要从文件中读取数据，比如可以很容易的实现一个从数据库里读记录的 Reader，或者从内存中的数据结构读取数据的 Reader。</p><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>在某些情况下，MapReduce 的使用者发现，如果在 Map 或 Reduce 操作过程中增加辅助的输出文件会比较省事。MapReduce 依靠程序 writer 把这种“副作用”变成原子的和幂等的。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作 rename 重新命名这个临时文件。</p><h2 id="跳过损坏的记录"><a href="#跳过损坏的记录" class="headerlink" title="跳过损坏的记录"></a>跳过损坏的记录</h2><p>每个 worker 进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。 在执行 Map 或者 Reduce 操作之前，MapReduce 库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用“最后一口气”通过 UDP 包向 master 发送处理的最后一条记录的序号。当 master 看到在处理某条特定记录不止失败一次时，master 就标志着条记录需要被跳过，并且在下次重新执行相关的 Map 或者 Reduce 任务的时候跳过这条记录。</p><h2 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h2><p>支持本地串行执行以方便调试</p><h2 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h2><p>master 支持嵌入 HTTP 服务器以显示一组状态信息页面，用户可以监控各种执行状态。状态信息页面显示了包括计算执行的进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、中间数据的字节数、输出的字节数、处理百分比等等</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>MapReduce 库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇 German 文档等等。</p><p>这些计数器的值周期性的从各个单独的 worker 机器上传递给 master（附加在 ping 的应答包中传递）。master 把执行成功的 Map 和 Reduce 任务的计数器值进行累计，当 MapReduce 操作完成之后，返回给用户代码。</p><p>计数器当前的值也会显示在 master 的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，master 要检查重复运行的 Map 或者 Reduce 任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>分布式的 Grep：Map 函数输出匹配某个模式的一行，Reduce 函数是一个恒等函数，即把中间数据复制到输出。</p><ul><li>计算 URL 访问频率：Map 函数处理日志中 web 页面请求的记录，然后输出 (URL,1)。Reduce 函数把相同 URL 的 value 值都累加起来，产生 (URL, 记录总数）结果。<br>网络链接倒排：Map 函数在源页面（source）中搜索所有的链接目标（target）并输出为 (target,source)。Reduce 函数把给定链接目标（target）的链接组合成一个列表，输出 (target,list(source))。</li><li>每个主机的检索词向量：检索词向量用一个（词，频率）列表来概述出现在文档或文档集中的最重要的一些词。Map 函数为每一个输入文档输出（主机名，检索词向量），其中主机名来自文档的 URL。Reduce 函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的（主机名，检索词向量）。</li><li>倒排索引：Map 函数分析每个文档输出一个（词，文档号）的列表，Reduce 函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出（词，list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。<br>分布式排序：Map 函数从每个记录提取 key，输出 (key,record)。Reduce 函数不改变任何的值。这个运算依赖分区机制和排序属性。</li></ul><h1 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h1><ul><li>约束编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；</li><li>网络带宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽。</li><li>多次执行相同的任务可以减少硬件配置不平衡带来的负面影响，同时解决了由于机器失效导致的数据丢失问题。</li></ul><h1 id="创新之处"><a href="#创新之处" class="headerlink" title="创新之处"></a>创新之处</h1><ul><li>通过简单的接口实现了自动的并行化和大规模的分布式计算，通过使用 MapReduce 模型接口实现了在大量普通 PC 机上的高性能计算。</li><li>向工业界证明了 MapReduce 模型在分布式计算上的可行性，拉开了分布式计算的序幕并影响了其后所有的计算框架，包括现在流行的批处理框架 Spark 和流处理框架 Flink 都很受其影响。</li></ul><h1 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h1><ul><li>基于历史局限性和当时的成本考虑，没有利用内存去更高效的处理数据，不过也为 Spark 提供了思路。</li><li>没有将资料调度和计算调度分离，使得 MapReduce 系统看起来较为冗杂。在开源的 Hadoop 生态中，MapReduce 现只关注于计算，具体的资源调度由 Yarn 管理。</li></ul><h1 id="相关系统"><a href="#相关系统" class="headerlink" title="相关系统"></a>相关系统</h1><ul><li>分布式存储系统：GFS&#x2F;Colossus&#x2F;HDFS</li><li>批处理框架：Spark</li><li>流处理框架：Flink</li><li>高可用机制：Chubby&#x2F;ZooKeeper</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li><a href="http://nil.csail.mit.edu/6.824/2020/notes/l01.txt">6.824 讲义</a></li><li><a href="http://nil.csail.mit.edu/6.824/2020/video/1.html">6.824 视频</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">论文</a></li><li><a href="https://github.com/Cxka/paper/blob/0a72fe0b354b65bac25e45163163eb2573f1faf2/map-reduce/map-reduce-cn.pdf">中文翻译</a></li><li><a href="https://blog.mrcroxx.com/posts/paper-reading/mapreduce-osdi04/">其他优质博客</a></li></ul><h1 id="补充MapReduce论文示例代码"><a href="#补充MapReduce论文示例代码" class="headerlink" title="补充MapReduce论文示例代码"></a>补充MapReduce论文示例代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mapreduce/mapreduce.h&quot;</span></span><br><br><span class="hljs-comment">// User’s map function</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCounter</span> : <span class="hljs-keyword">public</span> Mapper &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Map</span><span class="hljs-params">(<span class="hljs-type">const</span> MapInput&amp; input)</span> </span>&#123;<br>      <span class="hljs-type">const</span> string&amp; text = input.<span class="hljs-built_in">value</span>();<br>      <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ) &#123;<br>        <span class="hljs-comment">// Skip past leading whitespace</span><br>        <span class="hljs-keyword">while</span> ((i &lt; n) &amp;&amp; <span class="hljs-built_in">isspace</span>(text[i]))<br>          i++;<br><br>        <span class="hljs-comment">// Find word end</span><br>        <span class="hljs-type">int</span> start = i;<br>        <span class="hljs-keyword">while</span> ((i &lt; n) &amp;&amp; !<span class="hljs-built_in">isspace</span>(text[i]))<br>          i++;<br>        <br>        <span class="hljs-keyword">if</span> (start &lt; i)<br>          <span class="hljs-built_in">Emit</span>(text.<span class="hljs-built_in">substr</span>(start,i-start),<span class="hljs-string">&quot;1&quot;</span>);<br>      &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">REGISTER_MAPPER</span>(WordCounter);<br><br><span class="hljs-comment">// User’s reduce function</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span> : <span class="hljs-keyword">public</span> Reducer &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Reduce</span><span class="hljs-params">(ReduceInput* input)</span> </span>&#123;<br>    <span class="hljs-comment">// Iterate over all entries with the</span><br>    <span class="hljs-comment">// same key and add the values</span><br>    int64 value = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!input-&gt;<span class="hljs-built_in">done</span>()) &#123;<br>      value += <span class="hljs-built_in">StringToInt</span>(input-&gt;<span class="hljs-built_in">value</span>());<br>      input-&gt;<span class="hljs-built_in">NextValue</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Emit sum for input-&gt;key()</span><br>    <span class="hljs-built_in">Emit</span>(<span class="hljs-built_in">IntToString</span>(value));<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">REGISTER_REDUCER</span>(Adder);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-built_in">ParseCommandLineFlags</span>(argc, argv);<br><br>  MapReduceSpecification spec;<br><br>  <span class="hljs-comment">// Store list of input files into &quot;spec&quot;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>    MapReduceInput* input = spec.<span class="hljs-built_in">add_input</span>();<br>    input-&gt;<span class="hljs-built_in">set_format</span>(<span class="hljs-string">&quot;text&quot;</span>);<br>    input-&gt;<span class="hljs-built_in">set_filepattern</span>(argv[i]);<br>    input-&gt;<span class="hljs-built_in">set_mapper_class</span>(<span class="hljs-string">&quot;WordCounter&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Specify the output files:</span><br>  <span class="hljs-comment">// /gfs/test/freq-00000-of-00100</span><br>  <span class="hljs-comment">// /gfs/test/freq-00001-of-00100</span><br>  <span class="hljs-comment">// ...</span><br>  MapReduceOutput* out = spec.<span class="hljs-built_in">output</span>();<br>  out-&gt;<span class="hljs-built_in">set_filebase</span>(<span class="hljs-string">&quot;/gfs/test/freq&quot;</span>);<br>  out-&gt;<span class="hljs-built_in">set_num_tasks</span>(<span class="hljs-number">100</span>);<br>  out-&gt;<span class="hljs-built_in">set_format</span>(<span class="hljs-string">&quot;text&quot;</span>);<br>  out-&gt;<span class="hljs-built_in">set_reducer_class</span>(<span class="hljs-string">&quot;Adder&quot;</span>);<br><br>  <span class="hljs-comment">// Optional: do partial sums within map</span><br>  <span class="hljs-comment">// tasks to save network bandwidth</span><br>  out-&gt;<span class="hljs-built_in">set_combiner_class</span>(<span class="hljs-string">&quot;Adder&quot;</span>);<br><br>  <span class="hljs-comment">// Tuning parameters: use at most 2000</span><br>  <span class="hljs-comment">// machines and 100 MB of memory per task</span><br>  spec.<span class="hljs-built_in">set_machines</span>(<span class="hljs-number">2000</span>);<br>  spec.<span class="hljs-built_in">set_map_megabytes</span>(<span class="hljs-number">100</span>);<br>  spec.<span class="hljs-built_in">set_reduce_megabytes</span>(<span class="hljs-number">100</span>);<br><br>  <span class="hljs-comment">// Now run it</span><br>  MapReduceResult result;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">MapReduce</span>(spec, &amp;result)) <span class="hljs-built_in">abort</span>();<br><br>  <span class="hljs-comment">// Done: ’result’ structure contains info</span><br>  <span class="hljs-comment">// about counters, time taken, number of</span><br>  <span class="hljs-comment">// machines used, etc.</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习记录</title>
    <link href="/2023/11/04/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/04/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>网站学习链接：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><p>经验贴：<a href="https://zhuanlan.zhihu.com/p/383960650">https://zhuanlan.zhihu.com/p/383960650</a></p><ul><li><code>git brach -b &lt;branchName&gt;</code> 新建一个<code>branchName</code>分支，并切换到那个分支</li><li><code>git checkout branchName^</code> 使得HEAD指向<code>branchName</code>的前一个分支，有几个<code>^</code>就代表前移几个，如果<code>branchName</code> 有多个parent，那么<code>^num</code> 就是指选择跳到第几个parent</li><li><code>git checkout branchName~2</code> 使得HEAD指向<code>branchName</code> 的前2个分支，如果没有后面的数字就是默认1</li><li><code>git checkout HEAD~^2~2</code> ,<code>git branch -f bugWork HEAD~^2^</code>git的操作符还支持链式操作</li><li><code>git revert</code>用于撤销提交，生成一条新的提交来覆盖之前的修改，保留修改历史，语法：<code>git revert &lt;commit&gt;</code> ，其中，<code>&lt;commit&gt;</code>是<strong>要撤销的提交</strong>的哈希值或引用</li><li><code>git reset</code>用于重置分支的指针，可以选择保留或丢弃之前的修改，改变提交历史，语法：<code>git reset &lt;commit&gt;</code> ，其中，<code>&lt;commit&gt;</code>是<strong>要重置到的目标提交</strong>的哈希值或引用<ul><li><code>-soft</code>：重置分支的指针，但不改变工作区和暂存区的内容。之前的修改将被保留在暂存区中，你可以随时重新提交它们</li><li><code>-mixed</code>（默认选项）：重置分支的指针，并清除暂存区的内容。之前的修改将保留在工作区中，但不会自动提交</li><li><code>-hard</code>：重置分支的指针，并清除暂存区和工作区的内容。之前的修改将完全丢失，慎用该选项</li></ul></li><li>使用<code>git reset</code>会改变分支的提交历史。如果你在公共分支上使用<code>git reset</code>，并将其推送到远程仓库，可能会导致其他人的问题。因此，在公共分支上通常更推荐使用<code>git revert</code></li><li><code>git rebase &lt;branch&gt; &lt;based_branch&gt;</code> 可以指定将branch对based_branch进行rebase</li><li><code>git cherry-pick commit1 commit2</code> 可以将两个commit放到HEAD后面,注意commit的顺序就是这里排列的顺序</li><li><code>git rebase -i HEAD~4</code> 是一个 Git 命令，用于以<strong>交互方式</strong>进行历史提交的重新整理（rebase）。该命令允许你修改最近的 4 个提交，可以根据需要修改这些操作命令。常见的操作命令包括 “pick”（保留提交）、”edit”（修改提交）、”reword”（修改提交信息）、”squash”（合并提交）等</li><li><code>git rebase</code></li><li><code>git branch -f main caption</code> 用于将分支<code>main</code>的指针强制移动到指定的提交<code>caption</code>上</li><li><code>git commit --amend</code>是一个用于修改最近一次提交的Git命令</li><li><code>git tag tagName commitName</code> 给c1提交赋上v0标签</li><li><code>git push origin &lt;tagname&gt;</code> 将tag推送到远程</li><li><code>git describe &lt;commit&gt;</code> 如果不指定<code>&lt;commit&gt;</code>，则默认使用当前所在的提交。如果这个<code>&lt;commit&gt;</code> 有标签就输出相应的标签，如果没有就会去找最近的标签，生成一个描述，格式为<code>&lt;tag&gt;-&lt;num&gt;-g&lt;hash&gt;</code>，其中<code>&lt;tag&gt;</code>是最近的标签，<code>&lt;num&gt;</code>是指定提交与最近标签之间的提交数，<code>&lt;hash&gt;</code>是指定提交的简短哈希值</li><li><code>git fetch</code> 会获取远程厂库的所有分支的所有提交记录，并把<code>orgin/xxx</code> 指向对应的远程提交，但是它并不会更改本地的内容还有本地的分支</li><li><code>git pull</code> 实际上是<code>git fetch</code>和<code>git merge</code>的合集，它会获取远程更新并与当前对应分支合并</li><li><code>git pull --rebase</code> 是<code>git fetch</code> 和<code>git rebase</code> 的合集，它会获取远程更新并对其进行rebase</li><li><code>git push</code> 实际上会merge本地拷贝的<code>origin/xxxx</code>分支然后再提交</li><li><code>git checkout -b foo origin/main</code> 可以把<code>foo</code>和远程分支<code>origin/main</code>绑定起来</li><li><code>git branch -u o/main foo</code> 使得foo分支直接绑定远程分支main，如果当前分支就是foo，就可省略foo</li><li><code>git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</code> 可以修改branch的名字</li><li><code>git push origin main</code> 将本地 <code>main</code> 分支的提交推送到远程仓库 <code>origin</code> 的 <code>main</code> 分支的命令</li><li><code>git push origin &lt;source&gt;:&lt;destination&gt;</code> 将本地 <code>&lt;source&gt;</code> 分支的提交推送到远程仓库 <code>origin</code> 的 <code>&lt;destination&gt;</code> 分支的命令。这样可以将本地的修改共享给其他协作者，并将本地分支映射到远程仓库的不同分支。<code>source</code>既可以是<code>branch</code>的名字也可以是某个指定的提交位置例如<code>HEAD~2</code></li><li><code>git fetch origin &lt;source&gt;:&lt;destination&gt;</code> 将远程的厂库<code>origin</code>的<code>source</code>分支更新到本地<code>destination</code>分支。注意<code>source</code>也是既可以是分支名也可以是某个指定的提交位置。注意这样子的<code>o/xxxx</code>分支不会进行变化</li><li><code>git push origin :side</code> 会删除远程的side分支</li><li><code>git fetch origin :bugFix</code> 会在本地创建一个bugFix分支</li><li><code>git pull origin foo</code> 相当于：<code>git fetch origin foo; git merge o/foo</code></li><li><code>git pull origin bar~1:bugFix</code> 相当于：<code>git fetch origin bar~1:bugFix; git merge bugFix</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客基础使用指南</title>
    <link href="/2023/11/04/%E5%8D%9A%E5%AE%A2%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/04/%E5%8D%9A%E5%AE%A2%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="在本地写文章"><a href="#在本地写文章" class="headerlink" title="在本地写文章"></a>在本地写文章</h1><pre><code class="hljs">指令需要在根目录下的控制台中运行</code></pre><ul><li>直接创建新文章：<code>hexo new a</code></li><li>新建草稿：<code>hexo new draft b</code></li><li>将草稿变成发布文章：<code>hexo publish b</code></li><li>文章首部内容示例：  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我就是标题</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-09-25 23:32:04</span><br><span class="hljs-attr">comments:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#是否可评论 </span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">post</span> <span class="hljs-comment"># 公开文章 </span><br><span class="hljs-attr">toc:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#是否显示文章目录 </span><br><span class="hljs-attr">tags:</span>   <span class="hljs-comment">#标签 </span><br><span class="hljs-bullet">-</span> <span class="hljs-string">我就是新的标签1</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">老子是新的标签2</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="部署运行"><a href="#部署运行" class="headerlink" title="部署运行"></a>部署运行</h1><ul><li>清理缓存： <code>hexo clean</code></li><li>生成静态网页并部署到远程github厂库：<code>hexo g -d</code></li><li>启动服务：<code>hexo s</code></li><li>本地访问的链接：<code>http://localhost:4000/</code></li><li>远程访问链接：<code>https://slipegg.github.io/</code></li></ul><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><p>站点访问统计:<a href="https://console.leancloud.app/apps">国际版LeanCloud</a></p><p>github推送使用的是git，所以依赖的其实是本地的私钥</p><p>部署的参考文档：</p><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a></li><li><a href="https://blog.csdn.net/PaperJack/article/details/120479912">https://blog.csdn.net/PaperJack/article/details/120479912</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/04/hello-world/"/>
    <url>/2023/11/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/06/10/test/"/>
    <url>/2021/06/10/test/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2021/06/10/test/test.jpg" class="" title="图片引用方法一"><p><img src="/2021/06/10/test/test.jpg" alt="图片引用方法二"></p><p><img src="/images/test.jpg" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
