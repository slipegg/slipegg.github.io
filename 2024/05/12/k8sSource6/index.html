

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="滑滑蛋">
  <meta name="keywords" content="">
  
    <meta name="description" content="本次分析参考的K8s版本是v1.27.0。 前言在 k8s 集群调度中，亲和性相关的概念本质上都是控制 Pod 如何被调度 – 堆叠或打散。podAffinity 以及 podAntiAffinity 两个特性对 Pod 在不同拓扑域（拓扑键-拓扑值构成了一个拓扑域，例如region-east）的分布进行了一些控制，podAffinity 可以将无数个 Pod 调度到特定的某一个拓扑域，这是堆叠的">
<meta property="og:type" content="article">
<meta property="og:title" content="【K8s源码分析（六）】-K8s中Pod拓扑分布约束（Pod Topology Spread Constraints）插件介绍">
<meta property="og:url" content="http://example.com/2024/05/12/k8sSource6/index.html">
<meta property="og:site_name" content="滑滑蛋的个人博客">
<meta property="og:description" content="本次分析参考的K8s版本是v1.27.0。 前言在 k8s 集群调度中，亲和性相关的概念本质上都是控制 Pod 如何被调度 – 堆叠或打散。podAffinity 以及 podAntiAffinity 两个特性对 Pod 在不同拓扑域（拓扑键-拓扑值构成了一个拓扑域，例如region-east）的分布进行了一些控制，podAffinity 可以将无数个 Pod 调度到特定的某一个拓扑域，这是堆叠的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/05/12/k8sSource6/region.png">
<meta property="article:published_time" content="2024-05-12T15:04:34.000Z">
<meta property="article:modified_time" content="2024-05-24T15:14:12.297Z">
<meta property="article:author" content="滑滑蛋">
<meta property="article:tag" content="k8s">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/05/12/k8sSource6/region.png">
  
  
  
  <title>【K8s源码分析（六）】-K8s中Pod拓扑分布约束（Pod Topology Spread Constraints）插件介绍 - 滑滑蛋的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"d38d21fca521d897798e5bdd940a90d0","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"WMtHomhQYlrbIodTwoPU3gTY-MdYXbMMI","app_key":"pZeun9WfI1yaQrIoUbvTQrXv","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?d38d21fca521d897798e5bdd940a90d0";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>滑滑蛋</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【K8s源码分析（六）】-K8s中Pod拓扑分布约束（Pod Topology Spread Constraints）插件介绍"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-12 23:04" pubdate>
          2024年5月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【K8s源码分析（六）】-K8s中Pod拓扑分布约束（Pod Topology Spread Constraints）插件介绍</h1>
            
            
              <div class="markdown-body">
                
                <p>本次分析参考的K8s版本是<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/tree/release-1.27">v1.27.0</a>。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 k8s 集群调度中，<strong>亲和性</strong>相关的概念本质上都是控制 Pod 如何被调度 – <strong>堆叠或打散</strong>。<code>podAffinity</code> 以及 <code>podAntiAffinity</code> 两个特性对 Pod 在不同拓扑域（拓扑键-拓扑值构成了一个拓扑域，例如region-east）的分布进行了一些控制，<code>podAffinity</code> 可以将无数个 Pod 调度到特定的某一个拓扑域，这是<strong>堆叠</strong>的体现；<code>podAntiAffinity</code> 则可以控制一个拓扑域只存在一个 Pod，这是<strong>打散</strong>的体现。前面已经进行了介绍，详见：<a target="_blank" rel="noopener" href="https://slipegg.github.io/2024/05/11/k8sSource5/">K8s源码分析（五）-K8s中Pod亲和性调度插件介绍</a></p>
<p>但<code>podAffinity</code> 以及 <code>podAntiAffinity</code> 这两种情况都太极端了，在不少场景下都无法达到理想的效果，例如为了实现容灾和高可用，将业务 Pod 尽可能均匀的分布在不同可用区就很难实现。</p>
<p><code>PodTopologySpread</code>（Pod 拓扑分布约束） 特性的提出正是为了对 Pod 的调度分布提供更精细的控制，以提高服务可用性以及资源利用率，<code>PodTopologySpread</code> 由 <code>EvenPodsSpread</code> 特性门所控制，在 v1.16 版本第一次发布，并在 v1.18 版本进入 beta 阶段默认启用。</p>
<p>官方对其的介绍详见：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod Topology Spread Constraints</a></p>
<h2 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h2><p>这一特性的定义在<code>spec.topologySpreadConstraints</code>下，一些可以定义的字段如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># Configure a topology spread constraint</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">maxSkew:</span> <span class="hljs-string">&lt;integer&gt;</span><br>      <span class="hljs-attr">minDomains:</span> <span class="hljs-string">&lt;integer&gt;</span> <span class="hljs-comment"># optional</span><br>      <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&lt;string&gt;</span><br>      <span class="hljs-attr">whenUnsatisfiable:</span> <span class="hljs-string">&lt;string&gt;</span><br>      <span class="hljs-attr">labelSelector:</span> <span class="hljs-string">&lt;object&gt;</span><br>      <span class="hljs-attr">matchLabelKeys:</span> <span class="hljs-string">&lt;list&gt;</span> <span class="hljs-comment"># optional; beta since v1.27</span><br>      <span class="hljs-attr">nodeAffinityPolicy:</span> [<span class="hljs-string">Honor|Ignore</span>] <span class="hljs-comment"># optional; beta since v1.26</span><br>      <span class="hljs-attr">nodeTaintsPolicy:</span> [<span class="hljs-string">Honor|Ignore</span>] <span class="hljs-comment"># optional; beta since v1.26</span><br>  <span class="hljs-comment">### other Pod fields go here</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>topologyKey：</strong>这个拓扑约束所生效的目标拓扑键，计算分布不均匀程度时以其作为单位。例如region、zone、hostName等。</p>
</li>
<li><p><strong>maxSkew：</strong>描述了允许的最大pod的分布不均匀程度。不均匀程度由同一个拓扑键下各个拓扑值中包含的所有的node中匹配的pod的数量之和的<strong>最大值减去最小值</strong>得到。</p>
<p>  <img src="/2024/05/12/k8sSource6/region.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<p>  例如现在的拓扑键是region，总共有3个不同的拓扑值，分别为A、B、C，就是有3个拓扑域它们中分别有2、2、1个相匹配的pod，那么其不均匀程度就是2-1&#x3D;1。如过设置maxSkew为1，那么要维持这个maxSkew，pod就得调度到Region C中的任意一个node上去。</p>
</li>
<li><p><strong>whenUnsatisfiable：</strong>当不满足maxSkew约束的node时如何处理。值可以为：</p>
<ul>
<li><code>DoNotSchedule</code>（默认）告诉调度器不要调度。</li>
<li><code>ScheduleAnyway</code> 告诉调度器仍然继续调度，只是根据如何能将偏差最小化来对节点进行排序。</li>
</ul>
</li>
<li><p><strong>labelSelector：</strong>筛选需要匹配的pod的规则。</p>
</li>
<li><p><strong>minDomains（可选项）：</strong>符合条件的拓扑域的最小值。如果小于这个值，那么就设置全局中匹配到的pod的数量的最小值为0，这时候各个拓扑域下的node相匹配的pod数量需要小于等于maxSkew。如果拓扑域的数量大于这个值，那么就不会有影响。默认值为1，设置的值必须大于0。</p>
<p>  <strong>注意：</strong>在 Kubernetes v1.30 之前，<code>minDomains</code> 字段只有在启用了 <code>MinDomainsInPodTopologySpread</code> <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>时才可用（自 v1.28 起默认启用） 在早期的 Kubernetes 集群中，此特性门控可能被显式禁用或此字段可能不可用。</p>
</li>
<li><p><strong>matchLabelKeys（可选项，beta，v1.27启用）：</strong>在labelSelector之外进行额外的pod筛选，即labelSelector筛选后的pod<strong>必须还得包含这些key</strong>。注意其要求如果没有labelSelector就不能使用这个项，并且不能和labelSelector有相同的key。默认是空，即不可能该项。</p>
</li>
<li><p><strong>nodeAffinityPolicy（可选项，beta，v1.26启用）：</strong>定义如何对待nodeAffinity和nodeSelector。</p>
<ul>
<li><strong>Honor：</strong>只有匹配nodeAffinity&#x2F;nodeSelector的节点才会包含在计算中。</li>
<li><strong>Ignore：</strong>nodeAffinity&#x2F;nodeSelector 操作被忽略，所有节点都包含在计算中。</li>
</ul>
</li>
<li><p><strong>nodeTaintsPolicy （可选项，beta，v1.26启用）：定义如何处理污点节点。</strong></p>
<ul>
<li><strong>Honor：</strong>只查看没有污点的节点，以及要调度的pod 具有容忍度的污点的节点。</li>
<li><strong>Ignore：</strong>所有节点都包含在计算中。</li>
</ul>
</li>
</ul>
<p>当一个 Pod 定义多个<code>topologySpreadConstraint</code>时，这些约束将使用<strong>逻辑 AND 运算进行组合</strong>。因为可以有多个约束，所以有可能会出现调度到任意节点都无法满足的情况。</p>
<h1 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h1><p>该组件的相关代码都在<code>pkg/scheduler/framework/plugins/podtopologyspread</code>文件夹下，其包含的文件如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">podtopologyspread/<br>├── common.<span class="hljs-keyword">go</span><br>├── filtering.<span class="hljs-keyword">go</span><br>├── filtering_test.<span class="hljs-keyword">go</span><br>├── plugin.<span class="hljs-keyword">go</span><br>├── plugin_test.<span class="hljs-keyword">go</span><br>├── scoring.<span class="hljs-keyword">go</span><br>└── scoring_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>

<h2 id="plugin-go"><a href="#plugin-go" class="headerlink" title="plugin.go"></a>plugin.go</h2><p>查看其初始的部分，如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PodTopologySpread is a plugin that ensures pod&#x27;s topologySpreadConstraints is satisfied.</span><br><span class="hljs-keyword">type</span> PodTopologySpread <span class="hljs-keyword">struct</span> &#123;<br>	systemDefaulted                              <span class="hljs-type">bool</span><br>	parallelizer                                 parallelize.Parallelizer<br>	defaultConstraints                           []v1.TopologySpreadConstraint<br>	sharedLister                                 framework.SharedLister<br>	services                                     corelisters.ServiceLister<br>	replicationCtrls                             corelisters.ReplicationControllerLister<br>	replicaSets                                  appslisters.ReplicaSetLister<br>	statefulSets                                 appslisters.StatefulSetLister<br>	enableMinDomainsInPodTopologySpread          <span class="hljs-type">bool</span><br>	enableNodeInclusionPolicyInPodTopologySpread <span class="hljs-type">bool</span><br>	enableMatchLabelKeysInPodTopologySpread      <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">var</span> _ framework.PreFilterPlugin = &amp;PodTopologySpread&#123;&#125;<br><span class="hljs-keyword">var</span> _ framework.FilterPlugin = &amp;PodTopologySpread&#123;&#125;<br><span class="hljs-keyword">var</span> _ framework.PreScorePlugin = &amp;PodTopologySpread&#123;&#125;<br><span class="hljs-keyword">var</span> _ framework.ScorePlugin = &amp;PodTopologySpread&#123;&#125;<br><span class="hljs-keyword">var</span> _ framework.EnqueueExtensions = &amp;PodTopologySpread&#123;&#125;<br><br><span class="hljs-comment">// Name is the name of the plugin used in the plugin registry and configurations.</span><br><span class="hljs-keyword">const</span> Name = names.PodTopologySpread<br></code></pre></td></tr></table></figure>

<p>可以看到与上一次分析的亲和性调度插件类似，也是定义并实现了以下接口。</p>
<ul>
<li><strong>PreFilter</strong></li>
<li><strong>Filter</strong></li>
<li><strong>PreScore</strong></li>
<li><strong>Score</strong></li>
<li><strong>EnqueueExtensions</strong></li>
</ul>
<p>结构体中还有一些特别的额外变量，其含义如下：</p>
<ul>
<li><strong>systemDefaulted：</strong>是否使用了系统默认的拓扑约束</li>
<li><strong>parallelizer：</strong>一个并行处理工具</li>
<li><strong>defaultConstraints：</strong>默认的拓扑约束</li>
<li><strong>sharedLister：</strong>一个共享的列表器，它提供了对 Kubernetes 资源（如节点、Pods 等）的访问</li>
<li><strong>services：</strong>一个服务列表器，用于列出 Kubernetes 中的服务资源。</li>
<li><strong>replicationCtrls：</strong>一个副本控制器列表器，用于列出和访问 Kubernetes 中的副本控制器对象。</li>
<li><strong>replicaSets：</strong>一个副本集列表器，用于列出和访问 Kubernetes 中的副本集对象。</li>
<li><strong>statefulSets：</strong>一个有状态集列表器，用于列出和访问 Kubernetes 中的有状态集对象。</li>
<li><strong>enableMinDomainsInPodTopologySpread：</strong>控制是否启用 Pod 拓扑分布的最小域 <code>minDomains</code> 特性。</li>
<li><strong>enableNodeInclusionPolicyInPodTopologySpread：</strong>控制是否启用了节点包含策略特性，如果<strong>没有启用</strong>，那么就只考虑通过节点亲和性及node selector的node。但是<strong>如果启用了</strong>，就会根据各个拓扑约束的nodeAffinityPolicy和nodeTaintsPolicy 来考虑是否检查节点能否通过亲和性约束及node selector和节点污点特性。</li>
<li><strong>enableMatchLabelKeysInPodTopologySpread：</strong>控制是否启用在 Pod 拓扑分布中的<code>matchLabelKeys</code>特性。</li>
</ul>
<p>再查看其注册的事件，可以看到当<strong>pod有任何修改</strong>或者<strong>node有添加、删除、更新label的操作</strong>时，就会将调度失败的pod进行重新调度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// EventsToRegister returns the possible events that may make a Pod</span><br><span class="hljs-comment">// failed by this plugin schedulable.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> EventsToRegister() []framework.ClusterEvent &#123;<br>	<span class="hljs-keyword">return</span> []framework.ClusterEvent&#123;<br>		<span class="hljs-comment">// All ActionType includes the following events:</span><br>		<span class="hljs-comment">// - Add. An unschedulable Pod may fail due to violating topology spread constraints,</span><br>		<span class="hljs-comment">// adding an assigned Pod may make it schedulable.</span><br>		<span class="hljs-comment">// - Update. Updating on an existing Pod&#x27;s labels (e.g., removal) may make</span><br>		<span class="hljs-comment">// an unschedulable Pod schedulable.</span><br>		<span class="hljs-comment">// - Delete. An unschedulable Pod may fail due to violating an existing Pod&#x27;s topology spread constraints,</span><br>		<span class="hljs-comment">// deleting an existing Pod may make it schedulable.</span><br>		&#123;Resource: framework.Pod, ActionType: framework.All&#125;,<br>		<span class="hljs-comment">// Node add|delete|updateLabel maybe lead an topology key changed,</span><br>		<span class="hljs-comment">// and make these pod in scheduling schedulable or unschedulable.</span><br>		&#123;Resource: framework.Node, ActionType: framework.Add | framework.Delete | framework.UpdateNodeLabel&#125;,<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再看其初始化的构建函数<code>New</code>，如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New initializes a new plugin and returns it.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(plArgs runtime.Object, h framework.Handle, fts feature.Features)</span></span> (framework.Plugin, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-keyword">if</span> h.SnapshotSharedLister() == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;SnapshotSharedlister is nil&quot;</span>)<br>	&#125;<br>	args, err := getArgs(plArgs)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">if</span> err := validation.ValidatePodTopologySpreadArgs(<span class="hljs-literal">nil</span>, &amp;args); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	pl := &amp;PodTopologySpread&#123;<br>		parallelizer:                        h.Parallelizer(),<br>		sharedLister:                        h.SnapshotSharedLister(),<br>		defaultConstraints:                  args.DefaultConstraints,<br>		enableMinDomainsInPodTopologySpread: fts.EnableMinDomainsInPodTopologySpread,<br>		enableNodeInclusionPolicyInPodTopologySpread: fts.EnableNodeInclusionPolicyInPodTopologySpread,<br>		enableMatchLabelKeysInPodTopologySpread:      fts.EnableMatchLabelKeysInPodTopologySpread,<br>	&#125;<br>	<span class="hljs-keyword">if</span> args.DefaultingType == config.SystemDefaulting &#123;<br>		pl.defaultConstraints = systemDefaultConstraints<br>		pl.systemDefaulted = <span class="hljs-literal">true</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pl.defaultConstraints) != <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">if</span> h.SharedInformerFactory() == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;SharedInformerFactory is nil&quot;</span>)<br>		&#125;<br>		pl.setListers(h.SharedInformerFactory())<br>	&#125;<br>	<span class="hljs-keyword">return</span> pl, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="filtering-go"><a href="#filtering-go" class="headerlink" title="filtering.go"></a>filtering.go</h2><h3 id="PreFilter"><a href="#PreFilter" class="headerlink" title="PreFilter"></a>PreFilter</h3><p>首先查看其<code>PreFilter</code>函数，如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PreFilter invoked at the prefilter extension point.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> PreFilter(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod) (*framework.PreFilterResult, *framework.Status) &#123;<br>	s, err := pl.calPreFilterState(ctx, pod)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, framework.AsStatus(err)<br>	&#125;<br>	cycleState.Write(preFilterStateKey, s)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>再查看核心的<code>calPreFilterState</code>函数，如下，补充了部分注释。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// calPreFilterState computes preFilterState describing how pods are spread on topologies.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> calPreFilterState(ctx context.Context, pod *v1.Pod) (*preFilterState, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 获取所有节点信息的列表。</span><br>    allNodes, err := pl.sharedLister.NodeInfos().List()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果获取节点信息失败，返回错误。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;listing NodeInfos: %w&quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> constraints []topologySpreadConstraint<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pod.Spec.TopologySpreadConstraints) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 如果 Pod 规范中定义了拓扑分布约束，则使用这些约束。</span><br>        <span class="hljs-comment">// 由于 API 服务器中的特性门控会剥离规范，因此不需要再次检查特性门控，只需检查约束的长度。</span><br>        constraints, err = pl.filterTopologySpreadConstraints(<br>            pod.Spec.TopologySpreadConstraints, <span class="hljs-comment">// Pod 的拓扑分布约束。</span><br>            pod.Labels,                        <span class="hljs-comment">// Pod 的标签。</span><br>            v1.DoNotSchedule,                  <span class="hljs-comment">// Kubernetes 调度策略。</span><br>        )<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果获取 Pod 的硬拓扑分布约束失败，返回错误。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;obtaining pod&#x27;s hard topology spread constraints: %w&quot;</span>, err)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 Pod 规范中没有定义拓扑分布约束，则构建默认的约束。</span><br>        constraints, err = pl.buildDefaultConstraints(pod, v1.DoNotSchedule)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果设置默认的硬拓扑分布约束失败，返回错误。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;setting default hard topology spread constraints: %w&quot;</span>, err)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有拓扑分布约束，则返回一个空的 preFilterState。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(constraints) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;preFilterState&#123;&#125;, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 preFilterState 结构体。</span><br>    s := preFilterState&#123;<br>        Constraints:          constraints,<br>        TpKeyToCriticalPaths: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*criticalPaths, <span class="hljs-built_in">len</span>(constraints)),<br>        TpPairToMatchNum:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[topologyPair]<span class="hljs-type">int</span>, sizeHeuristic(<span class="hljs-built_in">len</span>(allNodes), constraints)),<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个切片来存储每个节点的拓扑对计数。</span><br>    tpCountsByNode := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[topologyPair]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(allNodes))<br>    <span class="hljs-comment">// 获取 Pod 的必需节点亲和性。</span><br>    requiredNodeAffinity := nodeaffinity.GetRequiredNodeAffinity(pod)<br>    processNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 对每个节点应用处理函数。</span><br>        nodeInfo := allNodes[i]<br>        node := nodeInfo.Node()<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果节点信息为空，则记录错误并返回。</span><br>            klog.ErrorS(<span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Node not found&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> !pl.enableNodeInclusionPolicyInPodTopologySpread &#123;<br>            <span class="hljs-comment">// 如果没有启用节点包含策略，则只对通过选择的节点应用分布。</span><br>            <span class="hljs-comment">// 忽略解析错误以保持向后兼容性。</span><br>            <span class="hljs-keyword">if</span> match, _ := requiredNodeAffinity.Match(node); !match &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 确保当前节点的标签包含所有 &#x27;Constraints&#x27; 中的拓扑键。</span><br>        <span class="hljs-keyword">if</span> !nodeLabelsMatchSpreadConstraints(node.Labels, constraints) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        tpCounts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[topologyPair]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(constraints))<br>        <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> constraints &#123;<br>            <span class="hljs-comment">// 检查节点是否与包含策略匹配。</span><br>            <span class="hljs-keyword">if</span> pl.enableNodeInclusionPolicyInPodTopologySpread &amp;&amp;<br>                !c.matchNodeInclusionPolicies(pod, node, requiredNodeAffinity) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-comment">// 创建拓扑对并计算与选择器匹配的 Pod 数量。</span><br>            pair := topologyPair&#123;key: c.TopologyKey, value: node.Labels[c.TopologyKey]&#125;<br>            count := countPodsMatchSelector(nodeInfo.Pods, c.Selector, pod.Namespace)<br>            tpCounts[pair] = count<br>        &#125;<br>        <span class="hljs-comment">// 将当前节点的拓扑对计数存储到切片中。</span><br>        tpCountsByNode[i] = tpCounts<br>    &#125;<br>    <span class="hljs-comment">// 并行处理所有节点。</span><br>    pl.parallelizer.Until(ctx, <span class="hljs-built_in">len</span>(allNodes), processNode, pl.Name())<br><br>    <span class="hljs-comment">// 累加每个节点的拓扑对计数到 preFilterState。</span><br>    <span class="hljs-keyword">for</span> _, tpCounts := <span class="hljs-keyword">range</span> tpCountsByNode &#123;<br>        <span class="hljs-keyword">for</span> tp, count := <span class="hljs-keyword">range</span> tpCounts &#123;<br>            s.TpPairToMatchNum[tp] += count<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> pl.enableMinDomainsInPodTopologySpread &#123;<br>        <span class="hljs-comment">// 如果启用了最小域特性，则计算每个拓扑键的域数量。</span><br>        s.TpKeyToDomainsNum = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(constraints))<br>        <span class="hljs-keyword">for</span> tp := <span class="hljs-keyword">range</span> s.TpPairToMatchNum &#123;<br>            s.TpKeyToDomainsNum[tp.key]++<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 为每个拓扑键计算最小匹配数。</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(constraints); i++ &#123;<br>        key := constraints[i].TopologyKey<br>        s.TpKeyToCriticalPaths[key] = newCriticalPaths()<br>    &#125;<br>    <span class="hljs-keyword">for</span> pair, num := <span class="hljs-keyword">range</span> s.TpPairToMatchNum &#123;<br>        s.TpKeyToCriticalPaths[pair.key].update(pair.value, num)<br>    &#125;<br><br>    <span class="hljs-comment">// 返回计算出的 preFilterState。</span><br>    <span class="hljs-keyword">return</span> &amp;s, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到该函数的主要作用还是统计各个拓扑域上符合条件的pod的数量。其流程如下：</p>
<ol>
<li><p>获取所有的节点信息</p>
</li>
<li><p>查看pod是否有自定义的拓扑分布约束，如果没有就构建一个默认的约束。</p>
<p> 构建默认约束的函数<code>buildDefaultConstraints</code>如下，注意其输入为要调度的pod和<code>noSchedule</code>级别。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// buildDefaultConstraints builds the constraints for a pod using</span><br><span class="hljs-comment">// .DefaultConstraints and the selectors from the services, replication</span><br><span class="hljs-comment">// controllers, replica sets and stateful sets that match the pod.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> buildDefaultConstraints(p *v1.Pod, action v1.UnsatisfiableConstraintAction) ([]topologySpreadConstraint, <span class="hljs-type">error</span>) &#123;<br>	constraints, err := pl.filterTopologySpreadConstraints(pl.defaultConstraints, p.Labels, action)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(constraints) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	selector := helper.DefaultSelector(p, pl.services, pl.replicationCtrls, pl.replicaSets, pl.statefulSets)<br>	<span class="hljs-keyword">if</span> selector.Empty() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> constraints &#123;<br>		constraints[i].Selector = selector<br>	&#125;<br>	<span class="hljs-keyword">return</span> constraints, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p> 其中主要的函数是<code>filterTopologySpreadConstraints</code>函数，其传入的是pl.defaultConstraints，如下，补充了部分注释。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// filterTopologySpreadConstraints 从 Pod 的拓扑分布约束中筛选出满足 whenUnsatisfiable 为指定 action 的约束。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> filterTopologySpreadConstraints(<br>    constraints []v1.TopologySpreadConstraint,  <span class="hljs-comment">// Kubernetes v1 版本的拓扑分布约束列表。</span><br>    podLabels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>,               <span class="hljs-comment">// Pod 的标签。</span><br>    action v1.UnsatisfiableConstraintAction,  <span class="hljs-comment">// 当约束不可满足时的动作。</span><br>) ([]topologySpreadConstraint, <span class="hljs-type">error</span>) &#123;  <span class="hljs-comment">// 返回筛选后的拓扑分布约束列表和错误（如果有的话）。</span><br><br>    <span class="hljs-keyword">var</span> result []topologySpreadConstraint  <span class="hljs-comment">// 初始化一个用于存放筛选结果的切片。</span><br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> constraints &#123;       <span class="hljs-comment">// 遍历所有的拓扑分布约束。</span><br>        <span class="hljs-keyword">if</span> c.WhenUnsatisfiable == action &#123;  <span class="hljs-comment">// 检查约束的 whenUnsatisfiable 字段是否与指定的 action 匹配。</span><br>            selector, err := metav1.LabelSelectorAsSelector(c.LabelSelector)  <span class="hljs-comment">// 将 LabelSelector 转换为 Selector。</span><br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 如果转换出错，返回错误。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>            &#125;<br><br>            <span class="hljs-comment">// 如果启用了按标签键匹配，并且约束中定义了 MatchLabelKeys，则从 Pod 标签中提取相应的标签。</span><br>            <span class="hljs-keyword">if</span> pl.enableMatchLabelKeysInPodTopologySpread &amp;&amp; <span class="hljs-built_in">len</span>(c.MatchLabelKeys) &gt; <span class="hljs-number">0</span> &#123;<br>                matchLabels := <span class="hljs-built_in">make</span>(labels.Set)  <span class="hljs-comment">// 初始化一个标签集合。</span><br>                <span class="hljs-keyword">for</span> _, labelKey := <span class="hljs-keyword">range</span> c.MatchLabelKeys &#123;  <span class="hljs-comment">// 遍历 MatchLabelKeys。</span><br>                    <span class="hljs-keyword">if</span> value, ok := podLabels[labelKey]; ok &#123;  <span class="hljs-comment">// 如果 Pod 标签中包含该键，则添加到集合中。</span><br>                        matchLabels[labelKey] = value<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果集合非空，则将标签集合与选择器合并。</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matchLabels) &gt; <span class="hljs-number">0</span> &#123;<br>                    selector = mergeLabelSetWithSelector(matchLabels, selector)<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 创建 topologySpreadConstraint 结构体实例，填充筛选出的约束的相关信息。</span><br>            tsc := topologySpreadConstraint&#123;<br>                MaxSkew:            c.MaxSkew,           <span class="hljs-comment">// 最大偏差数。</span><br>                TopologyKey:        c.TopologyKey,        <span class="hljs-comment">// 拓扑键。</span><br>                Selector:           selector,             <span class="hljs-comment">// 与标签匹配的选择器。</span><br>                <span class="hljs-comment">// 如果 MinDomains 为 nil，我们将其视为 1。</span><br>                MinDomains:         <span class="hljs-number">1</span>,<br>                <span class="hljs-comment">// 如果 NodeAffinityPolicy 为 nil，我们将其视为 &quot;Honor&quot;。</span><br>                NodeAffinityPolicy: v1.NodeInclusionPolicyHonor,<br>                <span class="hljs-comment">// 如果 NodeTaintsPolicy 为 nil，我们将其视为 &quot;Ignore&quot;。</span><br>                NodeTaintsPolicy:   v1.NodeInclusionPolicyIgnore,<br>            &#125;<br>            <span class="hljs-comment">// 如果启用了最小域特性，并且约束中定义了 MinDomains，则使用该值。</span><br>            <span class="hljs-keyword">if</span> pl.enableMinDomainsInPodTopologySpread &amp;&amp; c.MinDomains != <span class="hljs-literal">nil</span> &#123;<br>                tsc.MinDomains = *c.MinDomains<br>            &#125;<br>            <span class="hljs-comment">// 如果启用了节点包含策略特性，则根据约束中的设置更新 NodeAffinityPolicy 和 NodeTaintsPolicy。</span><br>            <span class="hljs-keyword">if</span> pl.enableNodeInclusionPolicyInPodTopologySpread &#123;<br>                <span class="hljs-keyword">if</span> c.NodeAffinityPolicy != <span class="hljs-literal">nil</span> &#123;<br>                    tsc.NodeAffinityPolicy = *c.NodeAffinityPolicy<br>                &#125;<br>                <span class="hljs-keyword">if</span> c.NodeTaintsPolicy != <span class="hljs-literal">nil</span> &#123;<br>                    tsc.NodeTaintsPolicy = *c.NodeTaintsPolicy<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将筛选出的拓扑分布约束添加到结果切片中。</span><br>            result = <span class="hljs-built_in">append</span>(result, tsc)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回筛选后的拓扑分布约束列表，如果没有错误发生，则返回 nil。</span><br>    <span class="hljs-keyword">return</span> result, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p> 其会遍历所有的constrain，只有满足默认的action，即v1.DoNotSchedule才会继续往下执行：</p>
<ol>
<li><p>处理pod的selector，注意到这里如果LabelKeys是enable的，会将LabelKeys中定义的label转化成selector，其方法是查看pod中该key对应的value，组成一个selector，然后调用<code>mergeLabelSetWithSelector</code>函数合并进原来的selector。如下</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeLabelSetWithSelector</span><span class="hljs-params">(matchLabels labels.Set, s labels.Selector)</span></span> labels.Selector &#123;<br>	mergedSelector := labels.SelectorFromSet(matchLabels)<br><br>	requirements, ok := s.Requirements()<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> s<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> requirements &#123;<br>		mergedSelector = mergedSelector.Add(r)<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> mergedSelector<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看是否默认配置启用了MinDomains特性，如果是就需改MinDomains为设定值。</p>
</li>
<li><p>查看是否默认配置了节点包含策略特性，如果没有就将Pod的节点亲和性约束和节点污点特性添加进来。</p>
</li>
</ol>
</li>
<li><p>如果拓扑约束为空就直接返回，否则初始化一个preFilterState结构体。该结构体的定义如下</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// preFilterState computed at PreFilter and used at Filter.</span><br><span class="hljs-comment">// It combines TpKeyToCriticalPaths and TpPairToMatchNum to represent:</span><br><span class="hljs-comment">// (1) critical paths where the least pods are matched on each spread constraint.</span><br><span class="hljs-comment">// (2) number of pods matched on each spread constraint.</span><br><span class="hljs-comment">// A nil preFilterState denotes it&#x27;s not set at all (in PreFilter phase);</span><br><span class="hljs-comment">// An empty preFilterState object denotes it&#x27;s a legit state and is set in PreFilter phase.</span><br><span class="hljs-comment">// Fields are exported for comparison during testing.</span><br><span class="hljs-keyword">type</span> preFilterState <span class="hljs-keyword">struct</span> &#123;<br>	Constraints []topologySpreadConstraint<br>	<span class="hljs-comment">// We record 2 critical paths instead of all critical paths here.</span><br>	<span class="hljs-comment">// criticalPaths[0].MatchNum always holds the minimum matching number.</span><br>	<span class="hljs-comment">// criticalPaths[1].MatchNum is always greater or equal to criticalPaths[0].MatchNum, but</span><br>	<span class="hljs-comment">// it&#x27;s not guaranteed to be the 2nd minimum match number.</span><br>	TpKeyToCriticalPaths <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*criticalPaths<br>	<span class="hljs-comment">// TpKeyToDomainsNum is keyed with topologyKey, and valued with the number of domains.</span><br>	TpKeyToDomainsNum <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>	<span class="hljs-comment">// TpPairToMatchNum is keyed with topologyPair, and valued with the number of matching pods.</span><br>	TpPairToMatchNum <span class="hljs-keyword">map</span>[topologyPair]<span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>各个变量的含义参考注释如下：</p>
<ul>
<li><p><strong>Constraints：</strong>拓扑约束</p>
</li>
<li><p><strong>TpKeyToCriticalPaths：</strong>是一个map，key是拓扑键，例如Region、hostName。注意再看一下<code>criticalPaths</code>的定义，如下</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CAVEAT: the reason that `[2]criticalPath` can work is based on the implementation of current</span><br><span class="hljs-comment">// preemption algorithm, in particular the following 2 facts:</span><br><span class="hljs-comment">// Fact 1: we only preempt pods on the same node, instead of pods on multiple nodes.</span><br><span class="hljs-comment">// Fact 2: each node is evaluated on a separate copy of the preFilterState during its preemption cycle.</span><br><span class="hljs-comment">// If we plan to turn to a more complex algorithm like &quot;arbitrary pods on multiple nodes&quot;, this</span><br><span class="hljs-comment">// structure needs to be revisited.</span><br><span class="hljs-comment">// Fields are exported for comparison during testing.</span><br><span class="hljs-comment">// 翻译：</span><br><span class="hljs-comment">// [2]criticalPath 之所以能够工作，是基于当前的抢占算法实现，特别是以下两个事实：</span><br><span class="hljs-comment">// 事实 1：我们只在同一个节点上抢占 pods，而不是在多个节点上的 pods。</span><br><span class="hljs-comment">// 事实 2：在每个节点的抢占周期中，对其评估时使用的是 preFilterState 的一个独立副本。 </span><br><span class="hljs-comment">// 如果我们计划转向更复杂的算法，如“多个节点上的任意 pods”，则需要重新审视这种结构。 </span><br><span class="hljs-comment">// 字段在测试期间被导出以供比较。</span><br><span class="hljs-keyword">type</span> criticalPaths [<span class="hljs-number">2</span>]<span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// TopologyValue denotes the topology value mapping to topology key.</span><br>	TopologyValue <span class="hljs-type">string</span><br>	<span class="hljs-comment">// MatchNum denotes the number of matching pods.</span><br>	MatchNum <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>  可以看到<code>criticalPaths</code>定义了这个拓扑键下的拓扑域中匹配的pod数量。</p>
<p>  而看注释可以得知<code>TpKeyToCriticalPaths[0]</code> 定义了这个域中最少匹配的pod的数量及相应的value，而<code>TpKeyToCriticalPaths[1]</code> 记录了另一个value的情况，它匹配的数量肯定不会比<code>TpKeyToCriticalPaths[0]</code> 小。</p>
</li>
<li><p><strong>TpKeyToDomainsNum：</strong>各个拓扑键下的拓扑域的数量。</p>
</li>
<li><p><strong>TpPairToMatchNum：</strong>各个拓扑域匹配的pod的数量。可以注意一下topologyPair的定义，如下：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> topologyPair <span class="hljs-keyword">struct</span> &#123;<br>	key   <span class="hljs-type">string</span><br>	value <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>并行遍历各个node，统计各个node上各个拓扑域中匹配到的pod的数量。其流程如下</p>
<ol>
<li><p>得到node的信息。</p>
</li>
<li><p>如果没有启用节点包含策略特性，那么就检查节点是否符合pod的节点亲和性及node selector的要求，如果不符合就直接返回，如下</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Match checks whether the pod is schedulable onto nodes according to</span><br><span class="hljs-comment">// the requirements in both nodeSelector and nodeAffinity.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s RequiredNodeAffinity)</span></span> Match(node *v1.Node) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-keyword">if</span> s.labelSelector != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> !s.labelSelector.Matches(labels.Set(node.Labels)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> s.nodeSelector != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> s.nodeSelector.Match(node)<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>检查当前node是否包含了约束需要的拓扑键，即是否有类似于约束要求的region的定义，如果没有就直接返回。</p>
</li>
<li><p>遍历每个拓扑约束：</p>
<ol>
<li><p>如果启用了节点包含策略特性，那么就根据配置有选择性地检查当前节点是否符合pod的节点亲和性及node selector的要求，以及是否符合节点污点及容忍的要求。如果不符合，就跳过这个拓扑约束。<code>matchNodeInclusionPolicies</code>函数如下</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tsc *topologySpreadConstraint)</span></span> matchNodeInclusionPolicies(pod *v1.Pod, node *v1.Node, require nodeaffinity.RequiredNodeAffinity) <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">if</span> tsc.NodeAffinityPolicy == v1.NodeInclusionPolicyHonor &#123;<br>		<span class="hljs-comment">// We ignore parsing errors here for backwards compatibility.</span><br>		<span class="hljs-keyword">if</span> match, _ := require.Match(node); !match &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> tsc.NodeTaintsPolicy == v1.NodeInclusionPolicyHonor &#123;<br>		<span class="hljs-keyword">if</span> _, untolerated := v1helper.FindMatchingUntoleratedTaint(node.Spec.Taints, pod.Spec.Tolerations, helper.DoNotScheduleTaintsFilterFunc()); untolerated &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>计算这个node上满足selector要求的pod的数量，<code>countPodsMatchSelector</code>函数如下：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPodsMatchSelector</span><span class="hljs-params">(podInfos []*framework.PodInfo, selector labels.Selector, ns <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> selector.Empty() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	count := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> podInfos &#123;<br>		<span class="hljs-comment">// Bypass terminating Pod (see #87621).</span><br>		<span class="hljs-keyword">if</span> p.Pod.DeletionTimestamp != <span class="hljs-literal">nil</span> || p.Pod.Namespace != ns &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> selector.Matches(labels.Set(p.Pod.Labels)) &#123;<br>			count++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 注意这里专门过来了已经删除的pod以及不和要调度的pod在同一namespace的pod。【或许未来可以考虑跨namespace的pod的拓扑约束】</p>
</li>
</ol>
</li>
<li><p>对各个拓扑域匹配的pod的数量进行记录。</p>
</li>
</ol>
</li>
<li><p>汇总统计结果，转化为记录各个拓扑域匹配的pod数量。</p>
</li>
<li><p>如果启用了<code>MinDomains</code>特性就统计各个拓扑键下拓扑值的数量。</p>
</li>
<li><p>统计各个拓扑域的最小匹配的pod数到TpKeyToCriticalPaths中，具体的更新方法如下，补充了部分注释：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *criticalPaths)</span></span> update(tpVal <span class="hljs-type">string</span>, num <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 首先验证 tpVal 是否已经存在于 criticalPaths 中</span><br>    i := <span class="hljs-number">-1</span> <span class="hljs-comment">// 初始化索引 i 为 -1，表示尚未找到匹配的拓扑值</span><br>    <span class="hljs-keyword">if</span> tpVal == p[<span class="hljs-number">0</span>].TopologyValue &#123;<br>        i = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果 tpVal 与第一个元素的拓扑值匹配，则索引 i 设为 0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> tpVal == p[<span class="hljs-number">1</span>].TopologyValue &#123;<br>        i = <span class="hljs-number">1</span> <span class="hljs-comment">// 如果 tpVal 与第二个元素的拓扑值匹配，则索引 i 设为 1</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 如果索引 i 是非负的，表示找到了 tpVal</span><br>        p[i].MatchNum = num <span class="hljs-comment">// 更新找到的拓扑值对应的匹配 pods 数量</span><br>        <span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>].MatchNum &gt; p[<span class="hljs-number">1</span>].MatchNum &#123;<br>            <span class="hljs-comment">// 如果第一个路径的匹配 pods 数量大于第二个路径，</span><br>            <span class="hljs-comment">// 则交换两个路径的拓扑值和匹配数量</span><br>            p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>], p[<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果索引 i 是 -1，表示 tpVal 在 criticalPaths 中不存在</span><br>        <span class="hljs-keyword">if</span> num &lt; p[<span class="hljs-number">0</span>].MatchNum &#123;<br>            <span class="hljs-comment">// 如果新的数量 num 小于第一个路径的匹配 pods 数量，</span><br>            <span class="hljs-comment">// 则用第一个路径的信息更新第二个路径</span><br>            p[<span class="hljs-number">1</span>] = p[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment">// 然后更新第一个路径的拓扑值和匹配数量</span><br>            p[<span class="hljs-number">0</span>].TopologyValue, p[<span class="hljs-number">0</span>].MatchNum = tpVal, num<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> num &lt; p[<span class="hljs-number">1</span>].MatchNum &#123;<br>            <span class="hljs-comment">// 如果新的数量 num 小于第二个路径的匹配 pods 数量，</span><br>            <span class="hljs-comment">// 则只更新第二个路径的拓扑值和匹配数量</span><br>            p[<span class="hljs-number">1</span>].TopologyValue, p[<span class="hljs-number">1</span>].MatchNum = tpVal, num<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 这个方法的逻辑是，首先检查传入的拓扑键 <code>tpVal</code> 是否已经存在于 <code>criticalPaths</code> 中。如果存在，就更新对应的 <code>MatchNum</code>。如果不存在，并且新的数量 <code>num</code> 小于已有的最小数量<code>p[0].MatchNum</code>，则进行相应的更新或替换，同时把原本p[0]的内容转移到p[1]。如果num介于<code>p[0].MatchNum</code>与<code>p[1].MatchNum</code>之间就更新<code>p[1].MatchNum</code>。如此保证一般情况下p[0]是最小的，p[1]是第二小的，除非出现了传入的拓扑值 <code>tpVal</code> 是已经存在于 <code>criticalPaths</code> 中的特殊情况。</p>
</li>
</ol>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><code>Filter</code>函数，如下，补充了部分注释。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Filter invoked at the filter extension point.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> Filter(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo) *framework.Status &#123;<br>    node := nodeInfo.Node()<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果节点信息为空，则返回错误状态</span><br>        <span class="hljs-keyword">return</span> framework.AsStatus(fmt.Errorf(<span class="hljs-string">&quot;node not found&quot;</span>))<br>    &#125;<br><br>    s, err := getPreFilterState(cycleState)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果获取预过滤状态失败，则返回错误状态</span><br>        <span class="hljs-keyword">return</span> framework.AsStatus(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 preFilterState 为空，这是合法的，表示所有待调度的 Pods 都可以容忍</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.Constraints) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    podLabelSet := labels.Set(pod.Labels)<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s.Constraints &#123;<br>        tpKey := c.TopologyKey<br>        tpVal, ok := node.Labels[c.TopologyKey]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            <span class="hljs-comment">// 如果节点缺少所需的标签，则记录日志并返回不可调度且不可解决的状态</span><br>            klog.V(<span class="hljs-number">5</span>).InfoS(<span class="hljs-string">&quot;Node doesn&#x27;t have required label&quot;</span>, <span class="hljs-string">&quot;node&quot;</span>, klog.KObj(node), <span class="hljs-string">&quot;label&quot;</span>, tpKey)<br>            <span class="hljs-keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonNodeLabelNotMatch)<br>        &#125;<br><br>        <span class="hljs-comment">// 得到全局最小匹配的pod数量</span><br>        minMatchNum, err := s.minMatchNum(tpKey, c.MinDomains, pl.enableMinDomainsInPodTopologySpread)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果在获取预过滤阶段预先计算的值时发生内部错误，则记录日志并继续</span><br>            klog.ErrorS(err, <span class="hljs-string">&quot;Internal error occurred while retrieving value precalculated in PreFilter&quot;</span>, <span class="hljs-string">&quot;topologyKey&quot;</span>, tpKey, <span class="hljs-string">&quot;paths&quot;</span>, s.TpKeyToCriticalPaths)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        selfMatchNum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> c.Selector.Matches(podLabelSet) &#123;<br>            <span class="hljs-comment">// 如果选择器与 Pod 的标签匹配，则自身匹配数量为 1</span><br>            selfMatchNum = <span class="hljs-number">1</span><br>        &#125;<br><br>        pair := topologyPair&#123;key: tpKey, value: tpVal&#125;<br>        matchNum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> tpCount, ok := s.TpPairToMatchNum[pair]; ok &#123;<br>            <span class="hljs-comment">// 如果找到拓扑对匹配的数量，则使用该数量</span><br>            matchNum = tpCount<br>        &#125;<br>        skew := matchNum + selfMatchNum - minMatchNum<br>        <span class="hljs-keyword">if</span> skew &gt; <span class="hljs-type">int</span>(c.MaxSkew) &#123;<br>            <span class="hljs-comment">// 如果偏差超过最大偏差，则记录日志并返回不可调度的状态</span><br>            klog.V(<span class="hljs-number">5</span>).InfoS(<span class="hljs-string">&quot;Node failed spreadConstraint: matchNum + selfMatchNum - minMatchNum &gt; maxSkew&quot;</span>, <span class="hljs-string">&quot;node&quot;</span>, klog.KObj(node), <span class="hljs-string">&quot;topologyKey&quot;</span>, tpKey, <span class="hljs-string">&quot;matchNum&quot;</span>, matchNum, <span class="hljs-string">&quot;selfMatchNum&quot;</span>, selfMatchNum, <span class="hljs-string">&quot;minMatchNum&quot;</span>, minMatchNum, <span class="hljs-string">&quot;maxSkew&quot;</span>, c.MaxSkew)<br>            <span class="hljs-keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonConstraintsNotMatch)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有约束都满足，则返回 nil，表示节点通过过滤</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的逻辑就比较简单了，整体流程如下。</p>
<ol>
<li>获取node信息及PreFilter的结果。</li>
<li>遍历处理每个拓扑约束constrain，注意这里的约束经过PreFilter筛选后都是没通过就不可以调度的硬约束。<ol>
<li><p>如果node没有这个约束需要查看的拓扑键就返回不通过筛选。</p>
</li>
<li><p>统计域中各个value全局最小的匹配到的node的数量<code>minMatchNum</code>，函数<code>minMatchNum</code>如下</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// minMatchNum returns the global minimum for the calculation of skew while taking MinDomains into account.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *preFilterState)</span></span> minMatchNum(tpKey <span class="hljs-type">string</span>, minDomains <span class="hljs-type">int32</span>, enableMinDomainsInPodTopologySpread <span class="hljs-type">bool</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>	paths, ok := s.TpKeyToCriticalPaths[tpKey]<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to retrieve path by topology key&quot;</span>)<br>	&#125;<br><br>	minMatchNum := paths[<span class="hljs-number">0</span>].MatchNum<br>	<span class="hljs-keyword">if</span> !enableMinDomainsInPodTopologySpread &#123;<br>		<span class="hljs-keyword">return</span> minMatchNum, <span class="hljs-literal">nil</span><br>	&#125;<br><br>	domainsNum, ok := s.TpKeyToDomainsNum[tpKey]<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to retrieve the number of domains by topology key&quot;</span>)<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> domainsNum &lt; <span class="hljs-type">int</span>(minDomains) &#123;<br>		<span class="hljs-comment">// When the number of eligible domains with matching topology keys is less than `minDomains`,</span><br>		<span class="hljs-comment">// it treats &quot;global minimum&quot; as 0.</span><br>		minMatchNum = <span class="hljs-number">0</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> minMatchNum, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p> 可以看到如果没有启用MinDomains特性，就直接返回最小值，如果启用了就查看这个拓扑键下拓扑值的数量，如果小于minDomains，就返回0，否则返回最小值。</p>
</li>
<li><p>如果自身也符合这个约束的label筛选要求，那么就设置<code>selfMatchNum</code>为1，否则设置为0。</p>
</li>
<li><p>得到node所在的这个拓扑域的匹配的pod的数量<code>matchNum</code> </p>
</li>
<li><p>计算偏差度，即<code>skew=matchNum + selfMatchNum - minMatchNum</code></p>
</li>
<li><p>如果偏差度<code>skew</code>大于可以容忍的最大偏差MaxSkew，那么就返回不通过筛选</p>
</li>
</ol>
</li>
<li>通过了所有的约束检查，返回nil</li>
</ol>
<h2 id="Scoring-go"><a href="#Scoring-go" class="headerlink" title="Scoring.go"></a>Scoring.go</h2><h3 id="PreScore"><a href="#PreScore" class="headerlink" title="PreScore"></a>PreScore</h3><p><code>PreScore</code>函数如下，补充了部分注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PreScore 在打分阶段之前构建并写入周期状态，这些状态将被 Score 和 NormalizeScore 使用。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> PreScore(<br>    ctx context.Context,<br>    cycleState *framework.CycleState,<br>    pod *v1.Pod,<br>    filteredNodes []*v1.Node,<br>) *framework.Status &#123;<br>    allNodes, err := pl.sharedLister.NodeInfos().List()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果获取所有节点信息失败，则返回错误状态</span><br>        <span class="hljs-keyword">return</span> framework.AsStatus(fmt.Errorf(<span class="hljs-string">&quot;getting all nodes: %w&quot;</span>, err))<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(filteredNodes) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(allNodes) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 如果没有过滤后的节点或所有节点，则无需打分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    state := &amp;preScoreState&#123;<br>        IgnoredNodes:           sets.NewString(),<br>        TopologyPairToPodCounts: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[topologyPair]*<span class="hljs-type">int64</span>),<br>    &#125;<br>    <span class="hljs-comment">// 仅在使用非系统默认的分布规则时，才要求节点拥有所有拓扑标签。</span><br>    <span class="hljs-comment">// 这允许没有区域标签的节点仍然可以进行主机名分布。</span><br>    requireAllTopologies := <span class="hljs-built_in">len</span>(pod.Spec.TopologySpreadConstraints) &gt; <span class="hljs-number">0</span> || !pl.systemDefaulted<br>    err = pl.initPreScoreState(state, pod, filteredNodes, requireAllTopologies)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果计算 preScoreState 失败，则返回错误状态</span><br>        <span class="hljs-keyword">return</span> framework.AsStatus(fmt.Errorf(<span class="hljs-string">&quot;calculating preScoreState: %w&quot;</span>, err))<br>    &#125;<br><br>    <span class="hljs-comment">// 如果传入的 Pod 没有软拓扑分布约束，则返回</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(state.Constraints) == <span class="hljs-number">0</span> &#123;<br>        cycleState.Write(preScoreStateKey, state)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 为了向后兼容性，忽略解析错误。</span><br>    requiredNodeAffinity := nodeaffinity.GetRequiredNodeAffinity(pod)<br>    processAllNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        nodeInfo := allNodes[i]<br>        node := nodeInfo.Node()<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> !pl.enableNodeInclusionPolicyInPodTopologySpread &#123;<br>            <span class="hljs-comment">// `node` 应该满足传入 Pod 的 NodeSelector/NodeAffinity</span><br>            <span class="hljs-keyword">if</span> match, _ := requiredNodeAffinity.Match(node); !match &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果 requireAllTopologies 为 true，并且 `node` 缺少拓扑标签，则跳过该节点</span><br>        <span class="hljs-keyword">if</span> requireAllTopologies &amp;&amp; !nodeLabelsMatchSpreadConstraints(node.Labels, state.Constraints) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> state.Constraints &#123;<br>            <span class="hljs-keyword">if</span> pl.enableNodeInclusionPolicyInPodTopologySpread &amp;&amp;<br>               !c.matchNodeInclusionPolicies(pod, node, requiredNodeAffinity) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            pair := topologyPair&#123;key: c.TopologyKey, value: node.Labels[c.TopologyKey]&#125;<br>            <span class="hljs-comment">// 如果当前拓扑对没有与任何候选节点关联，则继续以避免不必要的计算。</span><br>            <span class="hljs-comment">// 每个节点的计数也跳过，因为它们在 Score 阶段完成。</span><br>            tpCount := state.TopologyPairToPodCounts[pair]<br>            <span class="hljs-keyword">if</span> tpCount == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            count := countPodsMatchSelector(nodeInfo.Pods, c.Selector, pod.Namespace)<br>            <span class="hljs-comment">// 对于匹配选择器的 Pod 数量，增加拓扑对计数</span><br>            atomic.AddInt64(tpCount, <span class="hljs-type">int64</span>(count))<br>        &#125;<br>    &#125;<br>    pl.parallelizer.Until(ctx, <span class="hljs-built_in">len</span>(allNodes), processAllNode, pl.Name())<br><br>    <span class="hljs-comment">// 将 preScoreState 写入周期状态，以便后续的 Score 或 NormalizeScore 使用</span><br>    cycleState.Write(preScoreStateKey, state)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其流程如下：</p>
<ol>
<li><p>获取所有节点信息，检查是否有通过筛选的node，如果没有就直接返回</p>
</li>
<li><p>检查是否需要node有所有的拓扑键，如果采取的是自定义的约束或者不是系统默认的约束，就设置为必须得满足</p>
</li>
<li><p>初始化<code>preScoreState</code>变量，关键的<code>initPreScoreState</code>函数如下：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initPreScoreState 遍历 &quot;filteredNodes&quot; 以筛选出没有所需拓扑键的节点，并初始化：</span><br><span class="hljs-comment">// 1) s.TopologyPairToPodCounts: 以合格的拓扑对和节点名称为键。</span><br><span class="hljs-comment">// 2) s.IgnoredNodes: 不应被打分的节点集合。</span><br><span class="hljs-comment">// 3) s.TopologyNormalizingWeight: 基于拓扑中值的数量，给予每个约束的权重。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> initPreScoreState(s *preScoreState, pod *v1.Pod, filteredNodes []*v1.Node, requireAllTopologies <span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pod.Spec.TopologySpreadConstraints) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 如果 Pod 规范中定义了拓扑分布约束，则过滤这些约束</span><br>        s.Constraints, err = pl.filterTopologySpreadConstraints(<br>            pod.Spec.TopologySpreadConstraints, <span class="hljs-comment">// Pod 的拓扑分布约束</span><br>            pod.Labels,                       <span class="hljs-comment">// Pod 的标签</span><br>            v1.ScheduleAnyway,                <span class="hljs-comment">// 调度策略</span><br>        )<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果获取 Pod 的软拓扑分布约束时出错，则返回错误</span><br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;obtaining pod&#x27;s soft topology spread constraints: %w&quot;</span>, err)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 Pod 规范中没有定义拓扑分布约束，则构建默认约束</span><br>        s.Constraints, err = pl.buildDefaultConstraints(pod, v1.ScheduleAnyway)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果设置默认软拓扑分布约束时出错，则返回错误</span><br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;setting default soft topology spread constraints: %w&quot;</span>, err)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.Constraints) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 如果没有拓扑分布约束，则不需要进一步处理，直接返回 nil</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    topoSize := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s.Constraints)) <span class="hljs-comment">// 为每个约束维护一个拓扑大小的切片</span><br>    <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> filteredNodes &#123;<br>        <span class="hljs-comment">// 如果要求所有拓扑键并且节点标签不匹配分布约束，则将节点添加到忽略集合中</span><br>        <span class="hljs-keyword">if</span> requireAllTopologies &amp;&amp; !nodeLabelsMatchSpreadConstraints(node.Labels, s.Constraints) &#123;<br>            s.IgnoredNodes.Insert(node.Name)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i, constraint := <span class="hljs-keyword">range</span> s.Constraints &#123;<br>            <span class="hljs-comment">// 对于每个约束，检查节点是否有相应的拓扑键</span><br>            <span class="hljs-comment">// 如果是主机名标签，则跳过，因为主机名分布独立处理</span><br>            <span class="hljs-keyword">if</span> constraint.TopologyKey == v1.LabelHostname &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            pair := topologyPair&#123;key: constraint.TopologyKey, value: node.Labels[constraint.TopologyKey]&#125;<br>            <span class="hljs-comment">// 如果拓扑对在计数映射中不存在，则初始化它并增加相应约束的拓扑大小</span><br>            <span class="hljs-keyword">if</span> s.TopologyPairToPodCounts[pair] == <span class="hljs-literal">nil</span> &#123;<br>                s.TopologyPairToPodCounts[pair] = <span class="hljs-built_in">new</span>(<span class="hljs-type">int64</span>)<br>                topoSize[i]++<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 为每个约束初始化拓扑归一化权重，基于拓扑中值的数量</span><br>    s.TopologyNormalizingWeight = <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>, <span class="hljs-built_in">len</span>(s.Constraints))<br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s.Constraints &#123;<br>        sz := topoSize[i]<br>        <span class="hljs-comment">// 如果拓扑键是主机名，则使用过滤后的节点数减去忽略的节点数作为大小</span><br>        <span class="hljs-keyword">if</span> c.TopologyKey == v1.LabelHostname &#123;<br>            sz = <span class="hljs-built_in">len</span>(filteredNodes) - <span class="hljs-built_in">len</span>(s.IgnoredNodes)<br>        &#125;<br>        <span class="hljs-comment">// 计算并设置拓扑归一化权重</span><br>        s.TopologyNormalizingWeight[i] = topologyNormalizingWeight(sz)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p> 其运行流程如下</p>
<ol>
<li>查看pod是否有拓扑约束，如果有就读取，如果没有就创建一个系统默认的的拓扑约束，与PreFilter类似。</li>
<li>如果拓扑约束为空直接返回nil</li>
<li>开始遍历筛选过后的node<ol>
<li><p>如果需要检查是否包含所有的拓扑键，但是node没有全部的拓扑键，那么就将这个node加入到<code>IgnoredNodes</code>中，然后跳过这个node</p>
</li>
<li><p>遍历所有的拓扑约束：</p>
<ol>
<li>如果拓扑约束的拓扑键是<code>hostName</code>那么就跳过，因为其后面会特殊处理</li>
<li>查看是否在之前统计了这个node上对应的拓扑键-拓扑值，如果没有就加入，然后这个拓扑约束的<code>topoSize+1</code> 。故最后<code>topoSize</code>会记录各个拓扑约束中拓扑键对应的拓扑值的个数。</li>
</ol>
</li>
<li><p>计算各个拓扑约束的权重，也需要遍历所有的拓扑约束</p>
<ol>
<li>得到这个拓扑约束中<code>topoSize</code> 的值</li>
<li>如果拓扑约束的拓扑键是<code>hostName</code>，那么就将<code>topoSize</code> 设置为<code>len(filteredNodes) - len(s.IgnoredNodes)</code> ，即不能被忽略的node的个数</li>
<li>计算这个拓扑约束的权重，计算函数<code>topologyNormalizingWeight</code>如下</li>
</ol>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// topologyNormalizingWeight calculates the weight for the topology, based on</span><br><span class="hljs-comment">// the number of values that exist for a topology.</span><br><span class="hljs-comment">// Since &lt;size&gt; is at least 1 (all nodes that passed the Filters are in the</span><br><span class="hljs-comment">// same topology), and k8s supports 5k nodes, the result is in the interval</span><br><span class="hljs-comment">// &lt;1.09, 8.52&gt;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note: &lt;size&gt; could also be zero when no nodes have the required topologies,</span><br><span class="hljs-comment">// however we don&#x27;t care about topology weight in this case as we return a 0</span><br><span class="hljs-comment">// score for all nodes.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topologyNormalizingWeight</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">return</span> math.Log(<span class="hljs-type">float64</span>(size + <span class="hljs-number">2</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 权重即为<code>ln(topoSize+2)</code> ，即拓扑键对应的拓扑值种类越多，权重就越大，一般而言肯定是<code>hostName</code>这种拓扑键的约束权重最大了。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>如果权重不为空就将权重写入到<code>cycleState</code>中</p>
</li>
<li><p>得到要调度的pod的node亲和性</p>
</li>
<li><p>并行遍历各个node，流程如下</p>
<ol>
<li>得到node的信息</li>
<li>与PreFilter类似，如果没有启用节点包含策略，就检查是否通过了node亲和性及node selector的约束，如果没有直接返回</li>
<li>如果需要node有所有的拓扑键，但是node没有，那么也会直接返回</li>
<li>遍历每个拓扑约束，流程如下<ol>
<li><p>如果启用了节点包含策略特性，那么就根据配置有选择性地检查当前节点是否符合pod的节点亲和性及node selector的要求，以及是否符合节点污点及容忍的要求。如果不符合，就跳过这个拓扑约束。</p>
</li>
<li><p>如果拓扑键是hostName，也直接跳过（后面在<code>Score</code>时再计算）</p>
</li>
<li><p>计算这个拓扑约束的拓扑键对应的拓扑域上相匹配的pod的个数</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPodsMatchSelector</span><span class="hljs-params">(podInfos []*framework.PodInfo, selector labels.Selector, ns <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> selector.Empty() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	count := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> podInfos &#123;<br>		<span class="hljs-comment">// Bypass terminating Pod (see #87621).</span><br>		<span class="hljs-keyword">if</span> p.Pod.DeletionTimestamp != <span class="hljs-literal">nil</span> || p.Pod.Namespace != ns &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> selector.Matches(labels.Set(p.Pod.Labels)) &#123;<br>			count++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> count<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>将结果写入到<code>cycleState</code>中，与PreFilter基本是一样的操作，最后得到是各个各个拓扑域对应的匹配的pod的数量</p>
</li>
</ol>
<h3 id="Score"><a href="#Score" class="headerlink" title="Score"></a>Score</h3><p>代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Score invoked at the Score extension point.</span><br><span class="hljs-comment">// The &quot;score&quot; returned in this function is the matching number of pods on the `nodeName`,</span><br><span class="hljs-comment">// it is normalized later.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pl *PodTopologySpread)</span></span> Score(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodeName <span class="hljs-type">string</span>) (<span class="hljs-type">int64</span>, *framework.Status) &#123;<br>	nodeInfo, err := pl.sharedLister.NodeInfos().Get(nodeName)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, framework.AsStatus(fmt.Errorf(<span class="hljs-string">&quot;getting node %q from Snapshot: %w&quot;</span>, nodeName, err))<br>	&#125;<br><br>	node := nodeInfo.Node()<br>	s, err := getPreScoreState(cycleState)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, framework.AsStatus(err)<br>	&#125;<br><br>	<span class="hljs-comment">// Return if the node is not qualified.</span><br>	<span class="hljs-keyword">if</span> s.IgnoredNodes.Has(node.Name) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-comment">// For each present &lt;pair&gt;, current node gets a credit of &lt;matchSum&gt;.</span><br>	<span class="hljs-comment">// And we sum up &lt;matchSum&gt; and return it as this node&#x27;s score.</span><br>	<span class="hljs-keyword">var</span> score <span class="hljs-type">float64</span><br>	<span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s.Constraints &#123;<br>		<span class="hljs-keyword">if</span> tpVal, ok := node.Labels[c.TopologyKey]; ok &#123;<br>			<span class="hljs-keyword">var</span> cnt <span class="hljs-type">int64</span><br>			<span class="hljs-keyword">if</span> c.TopologyKey == v1.LabelHostname &#123;<br>				cnt = <span class="hljs-type">int64</span>(countPodsMatchSelector(nodeInfo.Pods, c.Selector, pod.Namespace))<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				pair := topologyPair&#123;key: c.TopologyKey, value: tpVal&#125;<br>				cnt = *s.TopologyPairToPodCounts[pair]<br>			&#125;<br>			score += scoreForCount(cnt, c.MaxSkew, s.TopologyNormalizingWeight[i])<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">int64</span>(math.Round(score)), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其流程比较简明，如下</p>
<ol>
<li><p>得到node的信息及PreScore的结果</p>
</li>
<li><p>如果node在没通过筛选需要被忽略的node，即<code>IgnoredNodes</code>中，那么返回分数为0</p>
</li>
<li><p>遍历各个拓扑约束，计算分数</p>
<ol>
<li><p>得到这个node对应在这个拓扑约束的拓扑键中的拓扑域</p>
</li>
<li><p>如果这个拓扑约束的拓扑键是hostName是hostName，那么就调用<code>countPodsMatchSelector</code>计算这个node上匹配的pod数量<code>cnt</code>，不然就从PreScore的结果中得到对应的拓扑域上匹配的pod数量<code>cnt</code></p>
</li>
<li><p>调用scoreForCount对当前的拓扑约束进行分数计算</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// scoreForCount calculates the score based on number of matching pods in a</span><br><span class="hljs-comment">// topology domain, the constraint&#x27;s maxSkew and the topology weight.</span><br><span class="hljs-comment">// `maxSkew-1` is added to the score so that differences between topology</span><br><span class="hljs-comment">// domains get watered down, controlling the tolerance of the score to skews.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scoreForCount</span><span class="hljs-params">(cnt <span class="hljs-type">int64</span>, maxSkew <span class="hljs-type">int32</span>, tpWeight <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(cnt)*tpWeight + <span class="hljs-type">float64</span>(maxSkew<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 计算方式为<code>cnt*拓扑约束的权重+maxSkew-1</code> 。【至于为什么要这样打分暂时也没想清楚】</p>
</li>
</ol>
</li>
<li><p>最终得到了各个拓扑约束下的总分，并返回</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://docs.youdianzhishi.com/k8s/scheduler/topology/">Pod 拓扑分布约束</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/k8s/" class="category-chain-item">k8s</a>
  
  
    <span>></span>
    
  <a href="/categories/k8s/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="category-chain-item">源码分析</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/k8s/" class="print-no-link">#k8s</a>
      
        <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="print-no-link">#源码分析</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【K8s源码分析（六）】-K8s中Pod拓扑分布约束（Pod Topology Spread Constraints）插件介绍</div>
      <div>http://example.com/2024/05/12/k8sSource6/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>滑滑蛋</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/09/CNCFIntroduction/" title="CNCF项目全景图介绍">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CNCF项目全景图介绍</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/11/k8sSource5/" title="【K8s源码分析（五）】-K8s中Pod亲和性调度插件介绍">
                        <span class="hidden-mobile">【K8s源码分析（五）】-K8s中Pod亲和性调度插件介绍</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"WMtHomhQYlrbIodTwoPU3gTY-MdYXbMMI","appKey":"pZeun9WfI1yaQrIoUbvTQrXv","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://wmthomhq.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         次
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
